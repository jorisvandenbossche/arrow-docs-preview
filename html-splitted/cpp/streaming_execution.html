
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Streaming execution engine &#8212; Apache Arrow v7.0.0.dev574+gbd1ea0bfe</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="canonical" href="https://arrow.apache.org/docs/cpp/streaming_execution.html" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Input / output and filesystems" href="io.html" />
    <link rel="prev" title="Compute Functions" href="compute.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-107500873-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    


    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
<a class="navbar-brand" href="index.html">
  <img src="_static/arrow.png" class="logo" alt="logo">
</a>


<div id="subproject-button" class="dropdown">
  <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    C++
  </button>
  <div class="dropdown-menu" aria-labelledby="dropdownMenuButton">
      
      <a class="nav-link" href="/c_glib">C/GLib</a>
      
      <a class="nav-link" href="/cpp">C++</a>
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/csharp/README.md">C#</a>
      
      <a class="nav-link" href="https://godoc.org/github.com/apache/arrow/go/arrow">Go</a>
      
      <a class="nav-link" href="/java">Java</a>
      
      <a class="nav-link" href="/js">JavaScript</a>
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/julia/Arrow/README.md">Julia</a>
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/matlab/README.md">MATLAB</a>
      
      <a class="nav-link" href="/python">Python</a>
      
      <a class="nav-link" href="/r">R</a>
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/ruby/README.md">Ruby</a>
      
      <a class="nav-link" href="https://docs.rs/crate/arrow/">Rust</a>
      
      <a class="nav-link" href="/status.html">Implementation status</a>
      
      <a class="nav-link" href="/format">Specifications and Protocols</a>
      
      <a class="nav-link" href="/developers">Developer documentation</a>
      
 </div>
</div>

<div id="version-search-wrapper">

<div id="version-button" class="dropdown">
    <button type="button" class="btn btn-secondary btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        7.0.0 (dev)
        <span class="caret"></span>
    </button>
    <div id="version_switcher" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<script type="text/javascript">
// Function to construct the target URL from the JSON components
function buildURL(entry) {
    var template = "https://arrow.apache.org/docs/{version}";  // supplied by jinja
    template = template.replace("{version}", entry.version);
    return template;
}

// Function to check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "streaming_execution.html",
          otherDocsHomepage = event.target.getAttribute("href");
    let tryUrl = `${otherDocsHomepage}${currentFilePath}`;
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    return false;
}

// Function to populate the version switcher
(function () {
    // get JSON config
    $.getJSON("/docs/_static/versions.json", function(data, textStatus, jqXHR) {
        // create the nodes first (before AJAX calls) to ensure the order is
        // correct (for now, links will go to doc version homepage)
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // construct the appropriate URL, and add it to the dropdown
            entry.url = buildURL(entry);
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.setAttribute("href", `${entry.url}`);
            node.textContent = `${entry.name}`;
            node.onclick = checkPageExistsAndRedirect;
            $("#version_switcher").append(node);
        });
    });
})();
</script>

<form id="search-box" class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>

</div>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="getting_started.html">
   User Guide
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="overview.html">
     High-Level Overview
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="conventions.html">
     Conventions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="build_system.html">
     Using Arrow C++ in your own project
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="memory.html">
     Memory Management
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="arrays.html">
     Arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="datatypes.html">
     Data Types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tables.html">
     Tabular Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="compute.html">
     Compute Functions
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Streaming execution engine
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="io.html">
     Input / output and filesystems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ipc.html">
     Reading and writing the Arrow IPC format
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parquet.html">
     Reading and writing Parquet files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="csv.html">
     Reading and Writing CSV files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="json.html">
     Reading JSON files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="dataset.html">
     Tabular Datasets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="flight.html">
     Arrow Flight RPC
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="examples/index.html">
   Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/cmake_minimal_build.html">
     Minimal build using CMake
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/compute_and_write_example.html">
     Compute and Write CSV Example
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/dataset_documentation_example.html">
     Arrow Datasets example
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/row_columnar_conversion.html">
     Row to columnar conversion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/tuple_range_conversion.html">
     std::tuple-like ranges to Arrow
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="api.html">
   API Reference
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="api/support.html">
     Programming Support
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/memory.html">
     Memory (management)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/datatype.html">
     Data Types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/array.html">
     Arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/scalar.html">
     Scalars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/builder.html">
     Array Builders
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/table.html">
     Two-dimensional Datasets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/c_abi.html">
     C Interfaces
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/compute.html">
     Compute Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/tensor.html">
     Tensors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/utilities.html">
     Utilities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/io.html">
     Input / output
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/ipc.html">
     Arrow IPC
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/formats.html">
     File Formats
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/cuda.html">
     CUDA support
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/flight.html">
     Arrow Flight RPC
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/filesystem.html">
     Filesystems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/dataset.html">
     Dataset
    </a>
   </li>
  </ul>
 </li>
</ul>

    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivation">
   Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constructing-execplan-objects">
   Constructing
   <code class="docutils literal notranslate">
    <span class="pre">
     ExecPlan
    </span>
   </code>
   objects
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                

<div class="tocsection editthispage">
    <a href="https://github.com/apache/arrow/edit/master/docs/source/cpp/streaming_execution.rst">
        <i class="fas fa-pencil-alt"></i> Edit this page
    </a>
</div>

              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="streaming-execution-engine">
<h1>Streaming execution engine<a class="headerlink" href="#streaming-execution-engine" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The streaming execution engine is experimental, and a stable API
is not yet guaranteed.</p>
</div>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>For many complex computations, successive direct <a class="reference internal" href="compute.html#invoking-compute-functions"><span class="std std-ref">invocation of
compute functions</span></a> is not feasible
in either memory or computation time. Doing so causes all intermediate
data to be fully materialized. To facilitate arbitrarily large inputs
and more efficient resource usage, Arrow also provides a streaming query
engine with which computations can be formulated and executed.</p>
<img alt="An example graph of a streaming execution workflow." src="_images/simple_graph.svg" /><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> is provided to reify the graph of operations in a query.
Batches of data (<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code>) flow along edges of the graph from
node to node. Structuring the API around streams of batches allows the
working set for each node to be tuned for optimal performance independent
of any other nodes in the graph. Each <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> processes batches
as they are pushed to it along an edge of the graph by upstream nodes
(its inputs), and pushes batches along an edge of the graph to downstream
nodes (its outputs) as they are finalized.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://doi.org/10.1017/s0956796818000102">SHAIKHHA, A., DASHTI, M., &amp; KOCH, C.
(2018). Push versus pull-based loop fusion in query engines.
Journal of Functional Programming, 28.</a></p>
</div>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code></dt><dd><p>Each node in the graph is an implementation of the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> interface.</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code></dt><dd><p>A set of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> is contained and (to an extent) coordinated by an
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecFactoryRegistry</span></code></dt><dd><p>Instances of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> are constructed by factory functions held
in a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecFactoryRegistry</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNodeOptions</span></code></dt><dd><p>Heterogenous parameters for factories of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> are bundled in an
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNodeOptions</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">Declaration</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">dplyr</span></code>-inspired helper for efficient construction of an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code></dt><dd><p>A lightweight container for a single chunk of data in the Arrow format. In
contrast to <a class="reference internal" href="api/table.html#_CPPv4N5arrow11RecordBatchE" title="arrow::RecordBatch"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RecordBatch</span></code></a>, <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code> is intended for use
exclusively in a streaming execution context (for example, it doesn’t have a
corresponding Python binding). Furthermore columns which happen to have a
constant value may be represented by a <a class="reference internal" href="api/scalar.html#_CPPv4N5arrow6ScalarE" title="arrow::Scalar"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Scalar</span></code></a> instead of an
<a class="reference internal" href="api/array.html#_CPPv4N5arrow5ArrayE" title="arrow::Array"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Array</span></code></a>. In addition, <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code> may carry
execution-relevant properties including a guaranteed-true-filter
for <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Expression</span></code> simplification.</p>
</dd>
</dl>
<p>An example <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> implementation which simply passes all input batches
through unchanged:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PassthruNode</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExecNode</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// InputReceived is the main entry point for ExecNodes. It is invoked</span>
  <span class="c1">// by an input of this node to push a batch here for processing.</span>
  <span class="kt">void</span> <span class="n">InputReceived</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// Since this is a passthru node we simply push the batch to our</span>
    <span class="c1">// only output here.</span>
    <span class="n">outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">InputReceived</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">batch</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ErrorReceived is called by an input of this node to report an error.</span>
  <span class="c1">// ExecNodes should always forward errors to their outputs unless they</span>
  <span class="c1">// are able to fully handle the error (this is rare).</span>
  <span class="kt">void</span> <span class="n">ErrorReceived</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="n">Status</span> <span class="n">error</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ErrorReceived</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// InputFinished is used to signal how many batches will ultimately arrive.</span>
  <span class="c1">// It may be called with any ordering relative to InputReceived/ErrorReceived.</span>
  <span class="kt">void</span> <span class="n">InputFinished</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">total_batches</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">InputFinished</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">total_batches</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ExecNodes may request that their inputs throttle production of batches</span>
  <span class="c1">// until they are ready for more, or stop production if no further batches</span>
  <span class="c1">// are required.  These signals should typically be forwarded to the inputs</span>
  <span class="c1">// of the ExecNode.</span>
  <span class="kt">void</span> <span class="n">ResumeProducing</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ResumeProducing</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">PauseProducing</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">PauseProducing</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">StopProducing</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">StopProducing</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>

  <span class="c1">// An ExecNode has a single output schema to which all its batches conform.</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">output_schema</span><span class="p">;</span>

  <span class="c1">// ExecNodes carry basic introspection for debugging purposes</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">kind_name</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;PassthruNode&quot;</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">label</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">SetLabel</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">ToString</span><span class="p">;</span>

  <span class="c1">// An ExecNode holds references to its inputs and outputs, so it is possible</span>
  <span class="c1">// to walk the graph of execution if necessary.</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">inputs</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">outputs</span><span class="p">;</span>

  <span class="c1">// StartProducing() and StopProducing() are invoked by an ExecPlan to</span>
  <span class="c1">// coordinate the graph-wide execution state.  These do not need to be</span>
  <span class="c1">// forwarded to inputs or outputs.</span>
  <span class="n">Status</span> <span class="nf">StartProducing</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">StopProducing</span><span class="p">()</span> <span class="k">override</span> <span class="p">{}</span>
  <span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finished</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that each method which is associated with an edge of the graph must be invoked
with an <code class="docutils literal notranslate"><span class="pre">ExecNode*</span></code> to identify the node which invoked it. For example, in an
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> which implements <code class="docutils literal notranslate"><span class="pre">JOIN</span></code> this tagging might be used to differentiate
between batches from the left or right inputs.
<code class="docutils literal notranslate"><span class="pre">InputReceived</span></code>, <code class="docutils literal notranslate"><span class="pre">ErrorReceived</span></code>, <code class="docutils literal notranslate"><span class="pre">InputFinished</span></code> may only be invoked by
the inputs of a node, while <code class="docutils literal notranslate"><span class="pre">ResumeProducing</span></code>, <code class="docutils literal notranslate"><span class="pre">PauseProducing</span></code>, <code class="docutils literal notranslate"><span class="pre">StopProducing</span></code>
may only be invoked by outputs of a node.</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> contains the associated instances of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code>
and is used to start and stop execution of all nodes and for querying/awaiting
their completion:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// construct an ExecPlan first to hold your nodes</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">plan</span><span class="p">,</span> <span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="n">default_exec_context</span><span class="p">()));</span>

<span class="c1">// ... add nodes to your ExecPlan</span>

<span class="c1">// start all nodes in the graph</span>
<span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">StartProducing</span><span class="p">());</span>

<span class="n">SetUserCancellationCallback</span><span class="p">([</span><span class="n">plan</span><span class="p">]</span> <span class="p">{</span>
  <span class="c1">// stop all nodes in the graph</span>
  <span class="n">plan</span><span class="o">-&gt;</span><span class="n">StopProducing</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">// Complete will be marked finished when all nodes have run to completion</span>
<span class="c1">// or acknowledged a StopProducing() signal. The ExecPlan should be kept</span>
<span class="c1">// alive until this future is marked finished.</span>
<span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">complete</span> <span class="o">=</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="constructing-execplan-objects">
<h2>Constructing <code class="docutils literal notranslate"><span class="pre">ExecPlan</span></code> objects<a class="headerlink" href="#constructing-execplan-objects" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The following will be superceded by construction from Compute IR, see ARROW-14074.</p>
</div>
<p>None of the concrete implementations of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> are exposed
in headers, so they can’t be constructed directly outside the
translation unit where they are defined. Instead, factories to
create them are provided in an extensible registry. This structure
provides a number of benefits:</p>
<ul class="simple">
<li><p>This enforces consistent construction.</p></li>
<li><p>It decouples implementations from consumers of the interface
(for example: we have two classes for scalar and grouped aggregate,
we can choose which to construct within the single factory by
checking whether grouping keys are provided)</p></li>
<li><p>This expedites integration with out-of-library extensions. For example
“scan” nodes are implemented in the separate <code class="docutils literal notranslate"><span class="pre">libarrow_dataset.so</span></code> library.</p></li>
<li><p>Since the class is not referencable outside the translation unit in which it
is defined, compilers can optimize more aggressively.</p></li>
</ul>
<p>Factories of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> can be retrieved by name from the registry.
The default registry is available through
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">:compute::default_exec_factory_registry</span></code>
and can be queried for the built-in factories:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// get the factory for &quot;filter&quot; nodes:</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">make_filter</span><span class="p">,</span>
                      <span class="n">default_exec_factory_registry</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetFactory</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">));</span>

<span class="c1">// factories take three arguments:</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">filter_node</span><span class="p">,</span> <span class="o">*</span><span class="n">make_filter</span><span class="p">(</span>
    <span class="c1">// the ExecPlan which should own this node</span>
    <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>

    <span class="c1">// nodes which will send batches to this node (inputs)</span>
    <span class="p">{</span><span class="n">scan_node</span><span class="p">},</span>

    <span class="c1">// parameters unique to &quot;filter&quot; nodes</span>
    <span class="n">FilterNodeOptions</span><span class="p">{</span><span class="n">filter_expression</span><span class="p">}));</span>

<span class="c1">// alternative shorthand:</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">filter_node</span><span class="p">,</span> <span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span>
    <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan_node</span><span class="p">},</span> <span class="n">FilterNodeOptions</span><span class="p">{</span><span class="n">filter_expression</span><span class="p">});</span>
</pre></div>
</div>
<p>Factories can also be added to the default registry as long as they are
convertible to <code class="docutils literal notranslate"><span class="pre">std::function&lt;Result&lt;ExecNode*&gt;(</span>
<span class="pre">ExecPlan*,</span> <span class="pre">std::vector&lt;ExecNode*&gt;,</span> <span class="pre">const</span> <span class="pre">ExecNodeOptions&amp;)&gt;</span></code>.</p>
<p>To build an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> representing a simple pipeline which
reads from a <a class="reference internal" href="api/table.html#_CPPv4N5arrow17RecordBatchReaderE" title="arrow::RecordBatchReader"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RecordBatchReader</span></code></a> then filters, projects, and
writes to disk:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RecordBatchReader</span><span class="o">&gt;</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">GetStreamOfBatches</span><span class="p">();</span>
<span class="n">ExecNode</span><span class="o">*</span> <span class="n">source_node</span> <span class="o">=</span> <span class="o">*</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span>
                                      <span class="n">SourceNodeOptions</span><span class="o">::</span><span class="n">FromReader</span><span class="p">(</span>
                                          <span class="n">reader</span><span class="p">,</span>
                                          <span class="n">GetCpuThreadPool</span><span class="p">()));</span>

<span class="n">ExecNode</span><span class="o">*</span> <span class="n">filter_node</span> <span class="o">=</span> <span class="o">*</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source_node</span><span class="p">},</span>
                                      <span class="n">FilterNodeOptions</span><span class="p">{</span>
                                        <span class="n">greater</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
                                      <span class="p">});</span>

<span class="n">ExecNode</span><span class="o">*</span> <span class="n">project_node</span> <span class="o">=</span> <span class="o">*</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;project&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">filter_node</span><span class="p">},</span>
                                       <span class="n">ProjectNodeOptions</span><span class="p">{</span>
                                         <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">1</span><span class="p">))},</span>
                                         <span class="p">{</span><span class="s">&quot;score + 1&quot;</span><span class="p">}</span>
                                       <span class="p">});</span>

<span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>
<span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">project_node</span><span class="p">},</span>
             <span class="n">WriteNodeOptions</span><span class="p">{</span><span class="cm">/*base_dir=*/</span><span class="s">&quot;/dat&quot;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">});</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">Declaration</span></code> is a <a class="reference external" href="https://dplyr.tidyverse.org">dplyr</a>-inspired
helper which further decreases the boilerplate associated with populating
an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> from C++:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RecordBatchReader</span><span class="o">&gt;</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">GetStreamOfBatches</span><span class="p">();</span>
<span class="n">ASSERT_OK</span><span class="p">(</span><span class="n">Declaration</span><span class="o">::</span><span class="n">Sequence</span><span class="p">(</span>
              <span class="p">{</span>
                  <span class="p">{</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">SourceNodeOptions</span><span class="o">::</span><span class="n">FromReader</span><span class="p">(</span>
                       <span class="n">reader</span><span class="p">,</span>
                       <span class="n">GetCpuThreadPool</span><span class="p">())},</span>
                  <span class="p">{</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">FilterNodeOptions</span><span class="p">{</span>
                       <span class="n">greater</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">3</span><span class="p">))}},</span>
                  <span class="p">{</span><span class="s">&quot;project&quot;</span><span class="p">,</span> <span class="n">ProjectNodeOptions</span><span class="p">{</span>
                       <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">1</span><span class="p">))},</span>
                       <span class="p">{</span><span class="s">&quot;score + 1&quot;</span><span class="p">}}},</span>
                  <span class="p">{</span><span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">WriteNodeOptions</span><span class="p">{</span><span class="cm">/*base_dir=*/</span><span class="s">&quot;/dat&quot;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">}},</span>
              <span class="p">})</span>
              <span class="p">.</span><span class="n">AddToPlan</span><span class="p">(</span><span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
</pre></div>
</div>
<p>Note that a source node can wrap anything which resembles a stream of batches.
For example, <a class="reference external" href="https://github.com/apache/arrow/pull/11032">PR#11032</a> adds
support for use of a <a class="reference external" href="https://duckdb.org">DuckDB</a> query as a source node.
Similarly, a sink node can wrap anything which absorbs a stream of batches.
In the example above we’re writing completed
batches to disk. However we can also collect these in memory into a <a class="reference internal" href="api/table.html#_CPPv4N5arrow5TableE" title="arrow::Table"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Table</span></code></a>
or forward them to a <a class="reference internal" href="api/table.html#_CPPv4N5arrow17RecordBatchReaderE" title="arrow::RecordBatchReader"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RecordBatchReader</span></code></a> as an out-of-graph stream.
This flexibility allows an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> to be used as streaming middleware
between any endpoints which support Arrow formatted batches.</p>
<p>An <a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset7DatasetE" title="arrow::dataset::Dataset"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::Dataset</span></code></a> can also be wrapped as a source node which
pushes all the dataset’s batches into an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code>. This factory is added
to the default registry with the name <code class="docutils literal notranslate"><span class="pre">&quot;scan&quot;</span></code> by calling
<code class="docutils literal notranslate"><span class="pre">arrow::dataset::internal::Initialize()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">GetDataset</span><span class="p">();</span>

<span class="n">ASSERT_OK</span><span class="p">(</span><span class="n">Declaration</span><span class="o">::</span><span class="n">Sequence</span><span class="p">(</span>
              <span class="p">{</span>
                  <span class="p">{</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span>
                     <span class="cm">/* push down predicate, projection, ... */</span><span class="p">}},</span>
                  <span class="p">{</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">FilterNodeOptions</span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">}},</span>
                  <span class="c1">// ...</span>
              <span class="p">})</span>
              <span class="p">.</span><span class="n">AddToPlan</span><span class="p">(</span><span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
</pre></div>
</div>
<p>Datasets may be scanned multiple times; just make multiple scan
nodes from that dataset. (Useful for a self-join, for example.)
Note that producing two scan nodes like this will perform all
reads and decodes twice.</p>
</div>
</div>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="compute.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Compute Functions</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="io.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Input / output and filesystems</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2016-2022 Apache Software Foundation.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.2.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>