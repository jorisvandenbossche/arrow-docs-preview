
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Streaming execution engine &#8212; Apache Arrow v8.0.0.dev205+gf59fba46e</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/blank.css" />
    <link rel="stylesheet" type="text/css" href="_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="canonical" href="https://arrow.apache.org/docs/cpp/streaming_execution.html" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Input / output and filesystems" href="io.html" />
    <link rel="prev" title="Compute Functions" href="compute.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script async="" src="https://www.google-analytics.com/analytics.js"></script>
<script>
                        window.ga = window.ga || function () {
                            (ga.q = ga.q || []).push(arguments) };
                        ga.l = +new Date;
                        ga('create', 'UA-107500873-1', 'auto');
                        ga('set', 'anonymizeIp', true);
                        ga('send', 'pageview');
                    </script>

  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    


    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
<a class="navbar-brand" href="index.html">
  <img src="_static/arrow.png" class="logo" alt="logo">
</a>


<div id="subproject-button" class="dropdown">
  <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownMenuButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    C++
  </button>
  <div class="dropdown-menu" aria-labelledby="dropdownMenuButton">
    
      
      <a class="nav-link" href="../c_glib/index.html">C/GLib</a>
      
    
      
      <a class="nav-link" href="../cpp/index.html">C++</a>
      
    
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/csharp/README.md">C#</a>
      
    
      
      <a class="nav-link" href="https://godoc.org/github.com/apache/arrow/go/arrow">Go</a>
      
    
      
      <a class="nav-link" href="../java/index.html">Java</a>
      
    
      
      <a class="nav-link" href="../js/index.html">JavaScript</a>
      
    
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/julia/Arrow/README.md">Julia</a>
      
    
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/matlab/README.md">MATLAB</a>
      
    
      
      <a class="nav-link" href="../python/index.html">Python</a>
      
    
      
      <a class="nav-link" href="../r/index.html">R</a>
      
    
      
      <a class="nav-link" href="https://github.com/apache/arrow/blob/master/ruby/README.md">Ruby</a>
      
    
      
      <a class="nav-link" href="https://docs.rs/crate/arrow/">Rust</a>
      
    
      
      <a class="nav-link" href="..//status.html/index.html">Implementation status</a>
      
    
      
      <a class="nav-link" href="../format/index.html">Specifications and Protocols</a>
      
    
      
      <a class="nav-link" href="../developers/index.html">Developer documentation</a>
      
    
 </div>
</div>

<div id="version-search-wrapper">

<div id="version-button" class="dropdown">
    <button type="button" class="btn btn-secondary btn-sm navbar-btn dropdown-toggle" id="version_switcher_button" data-toggle="dropdown">
        8.0.0 (dev)
        <span class="caret"></span>
    </button>
    <div id="version_switcher" class="dropdown-menu list-group-flush py-0" aria-labelledby="version_switcher_button">
    <!-- dropdown will be populated by javascript on page load -->
    </div>
</div>

<script type="text/javascript">
// Function to construct the target URL from the JSON components
function buildURL(entry) {
    var template = "https://arrow.apache.org/docs/{version}";  // supplied by jinja
    template = template.replace("{version}", entry.version);
    return template;
}

// Function to check if corresponding page path exists in other version of docs
// and, if so, go there instead of the homepage of the other docs version
function checkPageExistsAndRedirect(event) {
    const currentFilePath = "streaming_execution.html",
          otherDocsHomepage = event.target.getAttribute("href");
    let tryUrl = `${otherDocsHomepage}${currentFilePath}`;
    $.ajax({
        type: 'HEAD',
        url: tryUrl,
        // if the page exists, go there
        success: function() {
            location.href = tryUrl;
        }
    }).fail(function() {
        location.href = otherDocsHomepage;
    });
    return false;
}

// Function to populate the version switcher
(function () {
    // get JSON config
    $.getJSON("/docs/_static/versions.json", function(data, textStatus, jqXHR) {
        // create the nodes first (before AJAX calls) to ensure the order is
        // correct (for now, links will go to doc version homepage)
        $.each(data, function(index, entry) {
            // if no custom name specified (e.g., "latest"), use version string
            if (!("name" in entry)) {
                entry.name = entry.version;
            }
            // construct the appropriate URL, and add it to the dropdown
            entry.url = buildURL(entry);
            const node = document.createElement("a");
            node.setAttribute("class", "list-group-item list-group-item-action py-1");
            node.setAttribute("href", `${entry.url}`);
            node.textContent = `${entry.name}`;
            node.onclick = checkPageExistsAndRedirect;
            $("#version_switcher").append(node);
        });
    });
})();
</script>

<form id="search-box" class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>

</div>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="getting_started.html">
   User Guide
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="overview.html">
     High-Level Overview
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="conventions.html">
     Conventions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="build_system.html">
     Using Arrow C++ in your own project
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="memory.html">
     Memory Management
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="arrays.html">
     Arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="datatypes.html">
     Data Types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="tables.html">
     Tabular Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="compute.html">
     Compute Functions
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Streaming execution engine
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="io.html">
     Input / output and filesystems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ipc.html">
     Reading and writing the Arrow IPC format
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parquet.html">
     Reading and writing Parquet files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="csv.html">
     Reading and Writing CSV files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="json.html">
     Reading JSON files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="dataset.html">
     Tabular Datasets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="flight.html">
     Arrow Flight RPC
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="gdb.html">
     Debugging code using Arrow
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="examples/index.html">
   Examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/cmake_minimal_build.html">
     Minimal build using CMake
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/compute_and_write_example.html">
     Compute and Write CSV Example
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/dataset_documentation_example.html">
     Arrow Datasets example
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/row_columnar_conversion.html">
     Row to columnar conversion
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="examples/tuple_range_conversion.html">
     std::tuple-like ranges to Arrow
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="api.html">
   API Reference
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="api/support.html">
     Programming Support
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/memory.html">
     Memory (management)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/datatype.html">
     Data Types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/array.html">
     Arrays
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/scalar.html">
     Scalars
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/builder.html">
     Array Builders
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/table.html">
     Two-dimensional Datasets
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/c_abi.html">
     C Interfaces
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/compute.html">
     Compute Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/tensor.html">
     Tensors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/utilities.html">
     Utilities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/async.html">
     Asynchronous programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/io.html">
     Input / output
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/ipc.html">
     Arrow IPC
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/formats.html">
     File Formats
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/cuda.html">
     CUDA support
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/flight.html">
     Arrow Flight RPC
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/filesystem.html">
     Filesystems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="api/dataset.html">
     Dataset
    </a>
   </li>
  </ul>
 </li>
</ul>

    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivation">
   Motivation
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#overview">
   Overview
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constructing-execplan-objects">
   Constructing
   <code class="docutils literal notranslate">
    <span class="pre">
     ExecPlan
    </span>
   </code>
   objects
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#constructing-execnode-using-options">
   Constructing
   <code class="docutils literal notranslate">
    <span class="pre">
     ExecNode
    </span>
   </code>
   using Options
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#source">
     <code class="docutils literal notranslate">
      <span class="pre">
       source
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filter">
     <code class="docutils literal notranslate">
      <span class="pre">
       filter
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#project">
     <code class="docutils literal notranslate">
      <span class="pre">
       project
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#aggregate">
     <code class="docutils literal notranslate">
      <span class="pre">
       aggregate
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sink">
     <code class="docutils literal notranslate">
      <span class="pre">
       sink
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#consuming-sink">
     <code class="docutils literal notranslate">
      <span class="pre">
       consuming_sink
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#order-by-sink">
     <code class="docutils literal notranslate">
      <span class="pre">
       order_by_sink
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#select-k-sink">
     <code class="docutils literal notranslate">
      <span class="pre">
       select_k_sink
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#scan">
     <code class="docutils literal notranslate">
      <span class="pre">
       scan
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#write">
     <code class="docutils literal notranslate">
      <span class="pre">
       write
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#union">
     <code class="docutils literal notranslate">
      <span class="pre">
       union
      </span>
     </code>
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hash-join">
     <code class="docutils literal notranslate">
      <span class="pre">
       hash_join
      </span>
     </code>
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#summary">
   Summary
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                

<div class="tocsection editthispage">
    <a href="https://github.com/apache/arrow/edit/master/docs/source/cpp/streaming_execution.rst">
        <i class="fas fa-pencil-alt"></i> Edit this page
    </a>
</div>

              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="streaming-execution-engine">
<h1>Streaming execution engine<a class="headerlink" href="#streaming-execution-engine" title="Permalink to this headline">¶</a></h1>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The streaming execution engine is experimental, and a stable API
is not yet guaranteed.</p>
</div>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>For many complex computations, successive direct <a class="reference internal" href="compute.html#invoking-compute-functions"><span class="std std-ref">invocation of
compute functions</span></a> is not feasible
in either memory or computation time. Doing so causes all intermediate
data to be fully materialized. To facilitate arbitrarily large inputs
and more efficient resource usage, Arrow also provides a streaming query
engine with which computations can be formulated and executed.</p>
<img alt="An example graph of a streaming execution workflow." src="_images/simple_graph.svg" /><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> is provided to reify the graph of operations in a query.
Batches of data (<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code>) flow along edges of the graph from
node to node. Structuring the API around streams of batches allows the
working set for each node to be tuned for optimal performance independent
of any other nodes in the graph. Each <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> processes batches
as they are pushed to it along an edge of the graph by upstream nodes
(its inputs), and pushes batches along an edge of the graph to downstream
nodes (its outputs) as they are finalized.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://doi.org/10.1017/s0956796818000102">SHAIKHHA, A., DASHTI, M., &amp; KOCH, C.
(2018). Push versus pull-based loop fusion in query engines.
Journal of Functional Programming, 28.</a></p>
</div>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code></dt><dd><p>Each node in the graph is an implementation of the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> interface.</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code></dt><dd><p>A set of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> is contained and (to an extent) coordinated by an
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecFactoryRegistry</span></code></dt><dd><p>Instances of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> are constructed by factory functions held
in a <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecFactoryRegistry</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNodeOptions</span></code></dt><dd><p>Heterogenous parameters for factories of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> are bundled in an
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNodeOptions</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">Declaration</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">dplyr</span></code>-inspired helper for efficient construction of an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code>.</p>
</dd>
<dt><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code></dt><dd><p>A lightweight container for a single chunk of data in the Arrow format. In
contrast to <a class="reference internal" href="api/table.html#_CPPv4N5arrow11RecordBatchE" title="arrow::RecordBatch"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RecordBatch</span></code></a>, <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code> is intended for use
exclusively in a streaming execution context (for example, it doesn’t have a
corresponding Python binding). Furthermore columns which happen to have a
constant value may be represented by a <a class="reference internal" href="api/scalar.html#_CPPv4N5arrow6ScalarE" title="arrow::Scalar"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Scalar</span></code></a> instead of an
<a class="reference internal" href="api/array.html#_CPPv4N5arrow5ArrayE" title="arrow::Array"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Array</span></code></a>. In addition, <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">ExecBatch</span></code> may carry
execution-relevant properties including a guaranteed-true-filter
for <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Expression</span></code> simplification.</p>
</dd>
</dl>
<p>An example <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> implementation which simply passes all input batches
through unchanged:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PassthruNode</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ExecNode</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// InputReceived is the main entry point for ExecNodes. It is invoked</span>
  <span class="c1">// by an input of this node to push a batch here for processing.</span>
  <span class="kt">void</span> <span class="n">InputReceived</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// Since this is a passthru node we simply push the batch to our</span>
    <span class="c1">// only output here.</span>
    <span class="n">outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">InputReceived</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">batch</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ErrorReceived is called by an input of this node to report an error.</span>
  <span class="c1">// ExecNodes should always forward errors to their outputs unless they</span>
  <span class="c1">// are able to fully handle the error (this is rare).</span>
  <span class="kt">void</span> <span class="n">ErrorReceived</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="n">Status</span> <span class="n">error</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ErrorReceived</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// InputFinished is used to signal how many batches will ultimately arrive.</span>
  <span class="c1">// It may be called with any ordering relative to InputReceived/ErrorReceived.</span>
  <span class="kt">void</span> <span class="n">InputFinished</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">total_batches</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">outputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">InputFinished</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">total_batches</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// ExecNodes may request that their inputs throttle production of batches</span>
  <span class="c1">// until they are ready for more, or stop production if no further batches</span>
  <span class="c1">// are required.  These signals should typically be forwarded to the inputs</span>
  <span class="c1">// of the ExecNode.</span>
  <span class="kt">void</span> <span class="n">ResumeProducing</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ResumeProducing</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">PauseProducing</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">PauseProducing</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">StopProducing</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">output</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">StopProducing</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>

  <span class="c1">// An ExecNode has a single output schema to which all its batches conform.</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">output_schema</span><span class="p">;</span>

  <span class="c1">// ExecNodes carry basic introspection for debugging purposes</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">kind_name</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&quot;PassthruNode&quot;</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">label</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">SetLabel</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">ToString</span><span class="p">;</span>

  <span class="c1">// An ExecNode holds references to its inputs and outputs, so it is possible</span>
  <span class="c1">// to walk the graph of execution if necessary.</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">inputs</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">ExecNode</span><span class="o">::</span><span class="n">outputs</span><span class="p">;</span>

  <span class="c1">// StartProducing() and StopProducing() are invoked by an ExecPlan to</span>
  <span class="c1">// coordinate the graph-wide execution state.  These do not need to be</span>
  <span class="c1">// forwarded to inputs or outputs.</span>
  <span class="n">Status</span> <span class="nf">StartProducing</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">StopProducing</span><span class="p">()</span> <span class="k">override</span> <span class="p">{}</span>
  <span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finished</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that each method which is associated with an edge of the graph must be invoked
with an <code class="docutils literal notranslate"><span class="pre">ExecNode*</span></code> to identify the node which invoked it. For example, in an
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> which implements <code class="docutils literal notranslate"><span class="pre">JOIN</span></code> this tagging might be used to differentiate
between batches from the left or right inputs.
<code class="docutils literal notranslate"><span class="pre">InputReceived</span></code>, <code class="docutils literal notranslate"><span class="pre">ErrorReceived</span></code>, <code class="docutils literal notranslate"><span class="pre">InputFinished</span></code> may only be invoked by
the inputs of a node, while <code class="docutils literal notranslate"><span class="pre">ResumeProducing</span></code>, <code class="docutils literal notranslate"><span class="pre">PauseProducing</span></code>, <code class="docutils literal notranslate"><span class="pre">StopProducing</span></code>
may only be invoked by outputs of a node.</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> contains the associated instances of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code>
and is used to start and stop execution of all nodes and for querying/awaiting
their completion:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// construct an ExecPlan first to hold your nodes</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">plan</span><span class="p">,</span> <span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="n">default_exec_context</span><span class="p">()));</span>

<span class="c1">// ... add nodes to your ExecPlan</span>

<span class="c1">// start all nodes in the graph</span>
<span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">StartProducing</span><span class="p">());</span>

<span class="n">SetUserCancellationCallback</span><span class="p">([</span><span class="n">plan</span><span class="p">]</span> <span class="p">{</span>
  <span class="c1">// stop all nodes in the graph</span>
  <span class="n">plan</span><span class="o">-&gt;</span><span class="n">StopProducing</span><span class="p">();</span>
<span class="p">});</span>

<span class="c1">// Complete will be marked finished when all nodes have run to completion</span>
<span class="c1">// or acknowledged a StopProducing() signal. The ExecPlan should be kept</span>
<span class="c1">// alive until this future is marked finished.</span>
<span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">complete</span> <span class="o">=</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="constructing-execplan-objects">
<h2>Constructing <code class="docutils literal notranslate"><span class="pre">ExecPlan</span></code> objects<a class="headerlink" href="#constructing-execplan-objects" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The following will be superceded by construction from Compute IR, see ARROW-14074.</p>
</div>
<p>None of the concrete implementations of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> are exposed
in headers, so they can’t be constructed directly outside the
translation unit where they are defined. Instead, factories to
create them are provided in an extensible registry. This structure
provides a number of benefits:</p>
<ul class="simple">
<li><p>This enforces consistent construction.</p></li>
<li><p>It decouples implementations from consumers of the interface
(for example: we have two classes for scalar and grouped aggregate,
we can choose which to construct within the single factory by
checking whether grouping keys are provided)</p></li>
<li><p>This expedites integration with out-of-library extensions. For example
“scan” nodes are implemented in the separate <code class="docutils literal notranslate"><span class="pre">libarrow_dataset.so</span></code> library.</p></li>
<li><p>Since the class is not referencable outside the translation unit in which it
is defined, compilers can optimize more aggressively.</p></li>
</ul>
<p>Factories of <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> can be retrieved by name from the registry.
The default registry is available through
<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">:compute::default_exec_factory_registry</span></code>
and can be queried for the built-in factories:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// get the factory for &quot;filter&quot; nodes:</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">make_filter</span><span class="p">,</span>
                      <span class="n">default_exec_factory_registry</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">GetFactory</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">));</span>

<span class="c1">// factories take three arguments:</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">filter_node</span><span class="p">,</span> <span class="o">*</span><span class="n">make_filter</span><span class="p">(</span>
    <span class="c1">// the ExecPlan which should own this node</span>
    <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>

    <span class="c1">// nodes which will send batches to this node (inputs)</span>
    <span class="p">{</span><span class="n">scan_node</span><span class="p">},</span>

    <span class="c1">// parameters unique to &quot;filter&quot; nodes</span>
    <span class="n">FilterNodeOptions</span><span class="p">{</span><span class="n">filter_expression</span><span class="p">}));</span>

<span class="c1">// alternative shorthand:</span>
<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">filter_node</span><span class="p">,</span> <span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span>
    <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan_node</span><span class="p">},</span> <span class="n">FilterNodeOptions</span><span class="p">{</span><span class="n">filter_expression</span><span class="p">});</span>
</pre></div>
</div>
<p>Factories can also be added to the default registry as long as they are
convertible to <code class="docutils literal notranslate"><span class="pre">std::function&lt;Result&lt;ExecNode*&gt;(</span>
<span class="pre">ExecPlan*,</span> <span class="pre">std::vector&lt;ExecNode*&gt;,</span> <span class="pre">const</span> <span class="pre">ExecNodeOptions&amp;)&gt;</span></code>.</p>
<p>To build an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> representing a simple pipeline which
reads from a <a class="reference internal" href="api/table.html#_CPPv4N5arrow17RecordBatchReaderE" title="arrow::RecordBatchReader"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RecordBatchReader</span></code></a> then filters, projects, and
writes to disk:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RecordBatchReader</span><span class="o">&gt;</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">GetStreamOfBatches</span><span class="p">();</span>
<span class="n">ExecNode</span><span class="o">*</span> <span class="n">source_node</span> <span class="o">=</span> <span class="o">*</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span>
                                      <span class="n">SourceNodeOptions</span><span class="o">::</span><span class="n">FromReader</span><span class="p">(</span>
                                          <span class="n">reader</span><span class="p">,</span>
                                          <span class="n">GetCpuThreadPool</span><span class="p">()));</span>

<span class="n">ExecNode</span><span class="o">*</span> <span class="n">filter_node</span> <span class="o">=</span> <span class="o">*</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source_node</span><span class="p">},</span>
                                      <span class="n">FilterNodeOptions</span><span class="p">{</span>
                                        <span class="n">greater</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
                                      <span class="p">});</span>

<span class="n">ExecNode</span><span class="o">*</span> <span class="n">project_node</span> <span class="o">=</span> <span class="o">*</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;project&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">filter_node</span><span class="p">},</span>
                                       <span class="n">ProjectNodeOptions</span><span class="p">{</span>
                                         <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">1</span><span class="p">))},</span>
                                         <span class="p">{</span><span class="s">&quot;score + 1&quot;</span><span class="p">}</span>
                                       <span class="p">});</span>

<span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>
<span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">project_node</span><span class="p">},</span>
             <span class="n">WriteNodeOptions</span><span class="p">{</span><span class="cm">/*base_dir=*/</span><span class="s">&quot;/dat&quot;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">});</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">Declaration</span></code> is a <a class="reference external" href="https://dplyr.tidyverse.org">dplyr</a>-inspired
helper which further decreases the boilerplate associated with populating
an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> from C++:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">RecordBatchReader</span><span class="o">&gt;</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">GetStreamOfBatches</span><span class="p">();</span>
<span class="n">ASSERT_OK</span><span class="p">(</span><span class="n">Declaration</span><span class="o">::</span><span class="n">Sequence</span><span class="p">(</span>
              <span class="p">{</span>
                  <span class="p">{</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">SourceNodeOptions</span><span class="o">::</span><span class="n">FromReader</span><span class="p">(</span>
                       <span class="n">reader</span><span class="p">,</span>
                       <span class="n">GetCpuThreadPool</span><span class="p">())},</span>
                  <span class="p">{</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">FilterNodeOptions</span><span class="p">{</span>
                       <span class="n">greater</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">3</span><span class="p">))}},</span>
                  <span class="p">{</span><span class="s">&quot;project&quot;</span><span class="p">,</span> <span class="n">ProjectNodeOptions</span><span class="p">{</span>
                       <span class="p">{</span><span class="n">add</span><span class="p">(</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">),</span> <span class="n">literal</span><span class="p">(</span><span class="mi">1</span><span class="p">))},</span>
                       <span class="p">{</span><span class="s">&quot;score + 1&quot;</span><span class="p">}}},</span>
                  <span class="p">{</span><span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">WriteNodeOptions</span><span class="p">{</span><span class="cm">/*base_dir=*/</span><span class="s">&quot;/dat&quot;</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">}},</span>
              <span class="p">})</span>
              <span class="p">.</span><span class="n">AddToPlan</span><span class="p">(</span><span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
</pre></div>
</div>
<p>Note that a source node can wrap anything which resembles a stream of batches.
For example, <a class="reference external" href="https://github.com/apache/arrow/pull/11032">PR#11032</a> adds
support for use of a <a class="reference external" href="https://duckdb.org">DuckDB</a> query as a source node.
Similarly, a sink node can wrap anything which absorbs a stream of batches.
In the example above we’re writing completed
batches to disk. However we can also collect these in memory into a <a class="reference internal" href="api/table.html#_CPPv4N5arrow5TableE" title="arrow::Table"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Table</span></code></a>
or forward them to a <a class="reference internal" href="api/table.html#_CPPv4N5arrow17RecordBatchReaderE" title="arrow::RecordBatchReader"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">RecordBatchReader</span></code></a> as an out-of-graph stream.
This flexibility allows an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> to be used as streaming middleware
between any endpoints which support Arrow formatted batches.</p>
<p>An <a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset7DatasetE" title="arrow::dataset::Dataset"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::Dataset</span></code></a> can also be wrapped as a source node which
pushes all the dataset’s batches into an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code>. This factory is added
to the default registry with the name <code class="docutils literal notranslate"><span class="pre">&quot;scan&quot;</span></code> by calling
<code class="docutils literal notranslate"><span class="pre">arrow::dataset::internal::Initialize()</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span> <span class="o">=</span> <span class="n">GetDataset</span><span class="p">();</span>

<span class="n">ASSERT_OK</span><span class="p">(</span><span class="n">Declaration</span><span class="o">::</span><span class="n">Sequence</span><span class="p">(</span>
              <span class="p">{</span>
                  <span class="p">{</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span>
                     <span class="cm">/* push down predicate, projection, ... */</span><span class="p">}},</span>
                  <span class="p">{</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">FilterNodeOptions</span><span class="p">{</span><span class="cm">/* ... */</span><span class="p">}},</span>
                  <span class="c1">// ...</span>
              <span class="p">})</span>
              <span class="p">.</span><span class="n">AddToPlan</span><span class="p">(</span><span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
</pre></div>
</div>
<p>Datasets may be scanned multiple times; just make multiple scan
nodes from that dataset. (Useful for a self-join, for example.)
Note that producing two scan nodes like this will perform all
reads and decodes twice.</p>
</div>
<div class="section" id="constructing-execnode-using-options">
<h2>Constructing <code class="docutils literal notranslate"><span class="pre">ExecNode</span></code> using Options<a class="headerlink" href="#constructing-execnode-using-options" title="Permalink to this headline">¶</a></h2>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecNode</span></code> is the component we use as a building block
containing in-built operations with various functionalities.</p>
<p>This is the list of operations associated with the execution plan:</p>
<table class="colwidths-given table" id="id1">
<caption><span class="caption-text">Operations and Options</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Options</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">source</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::SourceNodeOptions</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">filter</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::FilterNodeOptions</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">project</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::ProjectNodeOptions</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">aggregate</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::AggregateNodeOptions</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">sink</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::SinkNodeOptions</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">consuming_sink</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::ConsumingSinkNodeOptions</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">order_by_sink</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::OrderBySinkNodeOptions</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">select_k_sink</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::SelectKSinkNodeOptions</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">scan</span></code></p></td>
<td><p><a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset15ScanNodeOptionsE" title="arrow::dataset::ScanNodeOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::ScanNodeOptions</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">hash_join</span></code></p></td>
<td><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::HashJoinNodeOptions</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">write</span></code></p></td>
<td><p><a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset16WriteNodeOptionsE" title="arrow::dataset::WriteNodeOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::WriteNodeOptions</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">union</span></code></p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>
<div class="section" id="source">
<span id="stream-execution-source-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">source</span></code><a class="headerlink" href="#source" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">source</span></code> operation can be considered as an entry point to create a streaming execution plan.
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::SourceNodeOptions</span></code> are used to create the <code class="docutils literal notranslate"><span class="pre">source</span></code> operation.  The
<code class="docutils literal notranslate"><span class="pre">source</span></code> operation is the most generic and flexible type of source currently available but it can
be quite tricky to configure.  To process data from files the scan operation is likely a simpler choice.</p>
<p>The source node requires some kind of function that can be called to poll for more data.  This
function should take no arguments and should return an
<code class="docutils literal notranslate"><span class="pre">arrow::Future&lt;std::shared_ptr&lt;arrow::util::optional&lt;arrow::RecordBatch&gt;&gt;&gt;</span></code>.
This function might be reading a file, iterating through an in memory structure, or receiving data
from a network connection.  The arrow library refers to these functions as <code class="docutils literal notranslate"><span class="pre">arrow::AsyncGenerator</span></code>
and there are a number of utilities for working with these functions.  For this example we use
a vector of record batches that we’ve already stored in memory.
In addition, the schema of the data must be known up front.  Arrow’s streaming execution
engine must know the schema of the data at each stage of the execution graph before any
processing has begun.  This means we must supply the schema for a source node separately
from the data itself.</p>
<p>Here we define a struct to hold the data generator definition. This includes in-memory batches, schema
and a function that serves as a data generator :</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">155</span><span class="k">struct</span> <span class="nc">BatchesWithSchema</span> <span class="p">{</span>
<span class="linenos">156</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;</span> <span class="n">batches</span><span class="p">;</span>
<span class="linenos">157</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Schema</span><span class="o">&gt;</span> <span class="n">schema</span><span class="p">;</span>
<span class="linenos">158</span>  <span class="c1">// // This method uses internal arrow utilities to</span>
<span class="linenos">159</span>  <span class="c1">// // convert a vector of record batches to an AsyncGenerator of optional batches</span>
<span class="linenos">160</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">gen</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="linenos">161</span>    <span class="k">auto</span> <span class="n">opt_batches</span> <span class="o">=</span> <span class="o">::</span><span class="n">arrow</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">MapVector</span><span class="p">(</span>
<span class="linenos">162</span>        <span class="p">[](</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">make_optional</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">batch</span><span class="p">));</span> <span class="p">},</span>
<span class="linenos">163</span>        <span class="n">batches</span><span class="p">);</span>
<span class="linenos">164</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">gen</span><span class="p">;</span>
<span class="linenos">165</span>    <span class="n">gen</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">MakeVectorGenerator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">opt_batches</span><span class="p">));</span>
<span class="linenos">166</span>    <span class="k">return</span> <span class="n">gen</span><span class="p">;</span>
<span class="linenos">167</span>  <span class="p">}</span>
<span class="linenos">168</span><span class="p">};</span>
</pre></div>
</div>
<p>Generating sample batches for computation:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">172</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">BatchesWithSchema</span><span class="o">&gt;</span> <span class="n">MakeBasicBatches</span><span class="p">()</span> <span class="p">{</span>
<span class="linenos">173</span>  <span class="n">BatchesWithSchema</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">174</span>  <span class="k">auto</span> <span class="n">field_vector</span> <span class="o">=</span> <span class="p">{</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span>
<span class="linenos">175</span>                       <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">boolean</span><span class="p">())};</span>
<span class="linenos">176</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">}));</span>
<span class="linenos">177</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}));</span>
<span class="linenos">178</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}));</span>
<span class="linenos">179</span>
<span class="linenos">180</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1_bool</span><span class="p">,</span>
<span class="linenos">181</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">BooleanType</span><span class="o">&gt;</span><span class="p">({</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">}));</span>
<span class="linenos">182</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2_bool</span><span class="p">,</span>
<span class="linenos">183</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">BooleanType</span><span class="o">&gt;</span><span class="p">({</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">}));</span>
<span class="linenos">184</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3_bool</span><span class="p">,</span>
<span class="linenos">185</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">BooleanType</span><span class="o">&gt;</span><span class="p">({</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">}));</span>
<span class="linenos">186</span>
<span class="linenos">187</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1</span><span class="p">,</span>
<span class="linenos">188</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">field_vector</span><span class="p">,</span> <span class="p">{</span><span class="n">b1_int</span><span class="p">,</span> <span class="n">b1_bool</span><span class="p">}));</span>
<span class="linenos">189</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2</span><span class="p">,</span>
<span class="linenos">190</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">field_vector</span><span class="p">,</span> <span class="p">{</span><span class="n">b2_int</span><span class="p">,</span> <span class="n">b2_bool</span><span class="p">}));</span>
<span class="linenos">191</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3</span><span class="p">,</span>
<span class="linenos">192</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">field_vector</span><span class="p">,</span> <span class="p">{</span><span class="n">b3_int</span><span class="p">,</span> <span class="n">b3_bool</span><span class="p">}));</span>
<span class="linenos">193</span>
<span class="linenos">194</span>  <span class="n">out</span><span class="p">.</span><span class="n">batches</span> <span class="o">=</span> <span class="p">{</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">};</span>
<span class="linenos">195</span>  <span class="n">out</span><span class="p">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">(</span><span class="n">field_vector</span><span class="p">);</span>
<span class="linenos">196</span>  <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">197</span><span class="p">}</span>
</pre></div>
</div>
<p>Example of using <code class="docutils literal notranslate"><span class="pre">source</span></code> (usage of sink is explained in detail in <a class="reference internal" href="#stream-execution-sink-docs"><span class="std std-ref">sink</span></a>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">326</span><span class="cm">/**</span>
<span class="linenos">327</span><span class="cm"> * \brief</span>
<span class="linenos">328</span><span class="cm"> * Source-Sink Example</span>
<span class="linenos">329</span><span class="cm"> * This example shows how a source and sink can be used</span>
<span class="linenos">330</span><span class="cm"> * in an execution plan. This includes source node receiving data</span>
<span class="linenos">331</span><span class="cm"> * and the sink node emits the data as an output represented in</span>
<span class="linenos">332</span><span class="cm"> * a table.</span>
<span class="linenos">333</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">334</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">335</span><span class="cm"> */</span>
<span class="linenos">336</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">337</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">338</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">339</span>
<span class="linenos">340</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">341</span>
<span class="linenos">342</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">343</span>
<span class="linenos">344</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">345</span>
<span class="linenos">346</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">347</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">348</span>
<span class="linenos">349</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">350</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">351</span>
<span class="linenos">352</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">353</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="filter">
<span id="stream-execution-filter-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">filter</span></code><a class="headerlink" href="#filter" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">filter</span></code> operation, as the name suggests, provides an option to define data filtering
criteria. It selects rows matching a given expression. Filters can be written using
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::Expression</span></code>. For example, if we wish to keep rows where the value
of column <code class="docutils literal notranslate"><span class="pre">b</span></code> is greater than 3,  then we can use the following expression.</p>
<p>Filter example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">357</span><span class="cm">/**</span>
<span class="linenos">358</span><span class="cm"> * \brief</span>
<span class="linenos">359</span><span class="cm"> * Source-Filter-Sink</span>
<span class="linenos">360</span><span class="cm"> * This example shows how a filter can be used in an execution plan,</span>
<span class="linenos">361</span><span class="cm"> * along with the source and sink operations. The output from the</span>
<span class="linenos">362</span><span class="cm"> * exeuction plan is obtained as a table via the sink node.</span>
<span class="linenos">363</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">364</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">365</span><span class="cm"> */</span>
<span class="linenos">366</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanFilterSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">367</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">368</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">369</span>
<span class="linenos">370</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">371</span>
<span class="linenos">372</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">373</span>  <span class="c1">// // specify the filter.  This filter removes all rows where the</span>
<span class="linenos">374</span>  <span class="c1">// value of the &quot;a&quot; column is greater than 3.</span>
<span class="linenos">375</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Expression</span> <span class="n">filter_opt</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">greater</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="n">cp</span><span class="o">::</span><span class="n">literal</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="linenos">376</span>  <span class="c1">// set filter for scanner : on-disk / push-down filtering.</span>
<span class="linenos">377</span>  <span class="c1">// This step can be skipped if you are not reading from disk.</span>
<span class="linenos">378</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">filter_opt</span><span class="p">;</span>
<span class="linenos">379</span>  <span class="c1">// empty projection</span>
<span class="linenos">380</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>
<span class="linenos">381</span>
<span class="linenos">382</span>  <span class="c1">// construct the scan node</span>
<span class="linenos">383</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Initialized Scanning Options&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">384</span>
<span class="linenos">385</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">386</span>
<span class="linenos">387</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">388</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Scan node options created&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">389</span>
<span class="linenos">390</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">391</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">392</span>
<span class="linenos">393</span>  <span class="c1">// pipe the scan node into a filter node</span>
<span class="linenos">394</span>  <span class="c1">// // Need to set the filter in scan node options and filter node options.</span>
<span class="linenos">395</span>  <span class="c1">// // At scan node it is used for on-disk / push-down filtering.</span>
<span class="linenos">396</span>  <span class="c1">// // At filter node it is used for in-memory filtering.</span>
<span class="linenos">397</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">filter</span><span class="p">;</span>
<span class="linenos">398</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span>
<span class="linenos">399</span>                                                 <span class="n">cp</span><span class="o">::</span><span class="n">FilterNodeOptions</span><span class="p">{</span><span class="n">filter_opt</span><span class="p">}));</span>
<span class="linenos">400</span>
<span class="linenos">401</span>  <span class="c1">// // finally, pipe the filter node into a sink node</span>
<span class="linenos">402</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">403</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">404</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">filter</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">405</span>
<span class="linenos">406</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">dataset</span><span class="o">-&gt;</span><span class="n">schema</span><span class="p">(),</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">407</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="project">
<span id="stream-execution-project-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">project</span></code><a class="headerlink" href="#project" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">project</span></code> operation rearranges, deletes, transforms, and creates columns.
Each output column is computed by evaluating an expression
against the source record batch. This is exposed via
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::ProjectNodeOptions</span></code> which requires,
an <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::Expression</span></code> and name for each of the output columns (if names are not
provided, the string representations of exprs will be used).</p>
<p>Project example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">412</span><span class="cm">/**</span>
<span class="linenos">413</span><span class="cm"> * \brief</span>
<span class="linenos">414</span><span class="cm"> * Scan-Project-Sink</span>
<span class="linenos">415</span><span class="cm"> * This example shows how Scan operation can be used to load the data</span>
<span class="linenos">416</span><span class="cm"> * into the execution plan, how project operation can be applied on the</span>
<span class="linenos">417</span><span class="cm"> * data stream and how the output is obtained as a table via the sink node.</span>
<span class="linenos">418</span><span class="cm"> *</span>
<span class="linenos">419</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">420</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">421</span><span class="cm"> */</span>
<span class="linenos">422</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanProjectSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">423</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">424</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">425</span>
<span class="linenos">426</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">427</span>
<span class="linenos">428</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">429</span>  <span class="c1">// projection</span>
<span class="linenos">430</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Expression</span> <span class="n">a_times_2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">call</span><span class="p">(</span><span class="s">&quot;multiply&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">cp</span><span class="o">::</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="n">cp</span><span class="o">::</span><span class="n">literal</span><span class="p">(</span><span class="mi">2</span><span class="p">)});</span>
<span class="linenos">431</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>
<span class="linenos">432</span>
<span class="linenos">433</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">434</span>
<span class="linenos">435</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">436</span>
<span class="linenos">437</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">438</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">439</span>
<span class="linenos">440</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">project</span><span class="p">;</span>
<span class="linenos">441</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;project&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span>
<span class="linenos">442</span>                                                  <span class="n">cp</span><span class="o">::</span><span class="n">ProjectNodeOptions</span><span class="p">{{</span><span class="n">a_times_2</span><span class="p">}}));</span>
<span class="linenos">443</span>  <span class="c1">// schema after projection =&gt; multiply(a, 2): int64</span>
<span class="linenos">444</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Schema after projection : </span><span class="se">\n</span><span class="s">&quot;</span>
<span class="linenos">445</span>            <span class="o">&lt;&lt;</span> <span class="n">project</span><span class="o">-&gt;</span><span class="n">output_schema</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">446</span>
<span class="linenos">447</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">448</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">449</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">project</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">450</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a * 2&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">())});</span>
<span class="linenos">451</span>
<span class="linenos">452</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">453</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregate">
<span id="stream-execution-aggregate-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">aggregate</span></code><a class="headerlink" href="#aggregate" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> node computes various types of aggregates over data.</p>
<p>Arrow supports two types of aggregates: “scalar” aggregates, and
“hash” aggregates. Scalar aggregates reduce an array or scalar input
to a single scalar output (e.g. computing the mean of a column). Hash
aggregates act like <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> in SQL and first partition data based
on one or more key columns, then reduce the data in each
partition. The <code class="docutils literal notranslate"><span class="pre">aggregate</span></code> node supports both types of computation,
and can compute any number of aggregations at once.</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::AggregateNodeOptions</span></code> is used to define the
aggregation criteria.  It takes a list of aggregation functions and
their options; a list of target fields to aggregate, one per function;
and a list of names for the output fields, one per function.
Optionally, it takes a list of columns that are used to partition the
data, in the case of a hash aggregation.  The aggregation functions
can be selected from <a class="reference internal" href="compute.html#aggregation-option-list"><span class="std std-ref">this list of aggregation functions</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This node is a “pipeline breaker” and will fully materialize
the dataset in memory.  In the future, spillover mechanisms
will be added which should alleviate this constraint.</p>
</div>
<p>The aggregation can provide results as a group or scalar. For instances,
an operation like <cite>hash_count</cite> provides the counts per each unique record
as a grouped result while an operation like <cite>sum</cite> provides a single record.</p>
<p>Scalar Aggregation example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">458</span><span class="cm">/**</span>
<span class="linenos">459</span><span class="cm"> * \brief</span>
<span class="linenos">460</span><span class="cm"> * Source-Aggregation-Sink</span>
<span class="linenos">461</span><span class="cm"> * This example shows how an aggregation operation can be applied on a</span>
<span class="linenos">462</span><span class="cm"> * execution plan resulting a scalar output. The source node loads the</span>
<span class="linenos">463</span><span class="cm"> * data and the aggregation (counting unique types in column &#39;a&#39;)</span>
<span class="linenos">464</span><span class="cm"> * is applied on this data. The output is obtained from the sink node as a table.</span>
<span class="linenos">465</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">466</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">467</span><span class="cm"> */</span>
<span class="linenos">468</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceScalarAggregateSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">469</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">470</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">471</span>
<span class="linenos">472</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">473</span>
<span class="linenos">474</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">475</span>
<span class="linenos">476</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">477</span>
<span class="linenos">478</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">479</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">480</span>  <span class="k">auto</span> <span class="n">aggregate_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">AggregateNodeOptions</span><span class="p">{</span><span class="cm">/*aggregates=*/</span><span class="p">{{</span><span class="s">&quot;sum&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">}},</span>
<span class="linenos">481</span>                                                    <span class="cm">/*targets=*/</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">},</span>
<span class="linenos">482</span>                                                    <span class="cm">/*names=*/</span><span class="p">{</span><span class="s">&quot;sum(a)&quot;</span><span class="p">}};</span>
<span class="linenos">483</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">484</span>      <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">aggregate</span><span class="p">,</span>
<span class="linenos">485</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;aggregate&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">aggregate_options</span><span class="p">));</span>
<span class="linenos">486</span>
<span class="linenos">487</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">488</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">aggregate</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">489</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;sum(a)&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">())});</span>
<span class="linenos">490</span>
<span class="linenos">491</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">492</span><span class="p">}</span>
</pre></div>
</div>
<p>Group Aggregation example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">496</span><span class="cm">/**</span>
<span class="linenos">497</span><span class="cm"> * \brief</span>
<span class="linenos">498</span><span class="cm"> * Source-Aggregation-Sink</span>
<span class="linenos">499</span><span class="cm"> * This example shows how an aggregation operation can be applied on a</span>
<span class="linenos">500</span><span class="cm"> * execution plan resulting a grouped output. The source node loads the</span>
<span class="linenos">501</span><span class="cm"> * data and the aggregation (counting unique types in column &#39;a&#39;) is</span>
<span class="linenos">502</span><span class="cm"> * applied on this data. The output is obtained from the sink node as a table.</span>
<span class="linenos">503</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">504</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">505</span><span class="cm"> */</span>
<span class="linenos">506</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceGroupAggregateSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">507</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">508</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">509</span>
<span class="linenos">510</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">511</span>
<span class="linenos">512</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">513</span>
<span class="linenos">514</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">515</span>
<span class="linenos">516</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">517</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">518</span>  <span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span> <span class="n">options</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span><span class="o">::</span><span class="n">ONLY_VALID</span><span class="p">);</span>
<span class="linenos">519</span>  <span class="k">auto</span> <span class="n">aggregate_options</span> <span class="o">=</span>
<span class="linenos">520</span>      <span class="n">cp</span><span class="o">::</span><span class="n">AggregateNodeOptions</span><span class="p">{</span><span class="cm">/*aggregates=*/</span><span class="p">{{</span><span class="s">&quot;hash_count&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">}},</span>
<span class="linenos">521</span>                               <span class="cm">/*targets=*/</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">},</span>
<span class="linenos">522</span>                               <span class="cm">/*names=*/</span><span class="p">{</span><span class="s">&quot;count(a)&quot;</span><span class="p">},</span>
<span class="linenos">523</span>                               <span class="cm">/*keys=*/</span><span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">}};</span>
<span class="linenos">524</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">525</span>      <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">aggregate</span><span class="p">,</span>
<span class="linenos">526</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;aggregate&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">aggregate_options</span><span class="p">));</span>
<span class="linenos">527</span>
<span class="linenos">528</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">529</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">aggregate</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">530</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span>
<span class="linenos">531</span>      <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;count(a)&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span>
<span class="linenos">532</span>      <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">boolean</span><span class="p">()),</span>
<span class="linenos">533</span>  <span class="p">});</span>
<span class="linenos">534</span>
<span class="linenos">535</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">536</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sink">
<span id="stream-execution-sink-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">sink</span></code><a class="headerlink" href="#sink" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">sink</span></code> operation provides output and is the final node of a streaming
execution definition. <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::SinkNodeOptions</span></code> interface is used to pass
the required options. Similar to the source operator the sink operator exposes the output
with a function that returns a record batch future each time it is called.  It is expected the
caller will repeatedly call this function until the generator function is exhausted (returns
<code class="docutils literal notranslate"><span class="pre">arrow::util::optional::nullopt</span></code>).  If this function is not called often enough then record batches
will accumulate in memory.  An execution plan should only have one
“terminal” node (one sink node).  An <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ExecPlan</span></code> can terminate early due to cancellation or
an error, before the output is fully consumed. However, the plan can be safely destroyed independently
of the sink, which will hold the unconsumed batches by <cite>exec_plan-&gt;finished()</cite>.</p>
<p>As a part of the Source Example, the Sink operation is also included;</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">326</span><span class="cm">/**</span>
<span class="linenos">327</span><span class="cm"> * \brief</span>
<span class="linenos">328</span><span class="cm"> * Source-Sink Example</span>
<span class="linenos">329</span><span class="cm"> * This example shows how a source and sink can be used</span>
<span class="linenos">330</span><span class="cm"> * in an execution plan. This includes source node receiving data</span>
<span class="linenos">331</span><span class="cm"> * and the sink node emits the data as an output represented in</span>
<span class="linenos">332</span><span class="cm"> * a table.</span>
<span class="linenos">333</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">334</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">335</span><span class="cm"> */</span>
<span class="linenos">336</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">337</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">338</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">339</span>
<span class="linenos">340</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">341</span>
<span class="linenos">342</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">343</span>
<span class="linenos">344</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">345</span>
<span class="linenos">346</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">347</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">348</span>
<span class="linenos">349</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">350</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">351</span>
<span class="linenos">352</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">353</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="consuming-sink">
<span id="stream-execution-consuming-sink-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">consuming_sink</span></code><a class="headerlink" href="#consuming-sink" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">consuming_sink</span></code> operator is a sink operation containing consuming operation within the
execution plan (i.e. the exec plan should not complete until the consumption has completed).
Unlike the <code class="docutils literal notranslate"><span class="pre">sink</span></code> node this node takes in a callback function that is expected to consume the
batch.  Once this callback has finished the execution plan will no longer hold any reference to
the batch.
The consuming function may be called before a previous invocation has completed.  If the consuming
function does not run quickly enough then many concurrent executions could pile up, blocking the
CPU thread pool.  The execution plan will not be marked finished until all consuming function callbacks
have been completed.
Once all batches have been delivered the execution plan will wait for the <cite>finish</cite> future to complete
before marking the execution plan finished.  This allows for workflows where the consumption function
converts batches into async tasks (this is currently done internally for the dataset write node).</p>
<p>Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// define a Custom SinkNodeConsumer</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">batches_seen</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;::</span><span class="n">Make</span><span class="p">();</span>
<span class="k">struct</span> <span class="nc">CustomSinkNodeConsumer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeConsumer</span> <span class="p">{</span>

    <span class="n">CustomSinkNodeConsumer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">batches_seen</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span><span class="n">finish</span><span class="p">)</span><span class="o">:</span>
    <span class="n">batches_seen</span><span class="p">(</span><span class="n">batches_seen</span><span class="p">),</span> <span class="n">finish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">finish</span><span class="p">))</span> <span class="p">{}</span>
    <span class="c1">// Consumption logic can be written here</span>
    <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">Consume</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
    <span class="c1">// data can be consumed in the expected way</span>
    <span class="c1">// transfer to another system or just do some work</span>
    <span class="c1">// and write to disk</span>
    <span class="p">(</span><span class="o">*</span><span class="n">batches_seen</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">Finish</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">finish</span><span class="p">;</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">batches_seen</span><span class="p">;</span>
    <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span><span class="p">;</span>

<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CustomSinkNodeConsumer</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">CustomSinkNodeConsumer</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batches_seen</span><span class="p">,</span> <span class="n">finish</span><span class="p">);</span>

<span class="n">arrow</span><span class="o">::</span><span class="n">compute</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span><span class="n">consuming_sink</span><span class="p">;</span>

<span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">consuming_sink</span><span class="p">,</span> <span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;consuming_sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
    <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">ConsumingSinkNodeOptions</span><span class="p">(</span><span class="n">consumer</span><span class="p">)));</span>
</pre></div>
</div>
<p>Consuming-Sink example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">540</span><span class="cm">/**</span>
<span class="linenos">541</span><span class="cm"> * \brief</span>
<span class="linenos">542</span><span class="cm"> * Source-ConsumingSink</span>
<span class="linenos">543</span><span class="cm"> * This example shows how the data can be consumed within the execution plan</span>
<span class="linenos">544</span><span class="cm"> * by using a ConsumingSink node. There is no data output from this execution plan.</span>
<span class="linenos">545</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">546</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">547</span><span class="cm"> */</span>
<span class="linenos">548</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceConsumingSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">549</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">550</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">551</span>
<span class="linenos">552</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">553</span>
<span class="linenos">554</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">555</span>
<span class="linenos">556</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">557</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">558</span>
<span class="linenos">559</span>  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">batches_seen</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="linenos">560</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;::</span><span class="n">Make</span><span class="p">();</span>
<span class="linenos">561</span>  <span class="k">struct</span> <span class="nc">CustomSinkNodeConsumer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeConsumer</span> <span class="p">{</span>
<span class="linenos">562</span>    <span class="n">CustomSinkNodeConsumer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;*</span> <span class="n">batches_seen</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span><span class="p">)</span>
<span class="linenos">563</span>        <span class="o">:</span> <span class="n">batches_seen</span><span class="p">(</span><span class="n">batches_seen</span><span class="p">),</span> <span class="n">finish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">finish</span><span class="p">))</span> <span class="p">{}</span>
<span class="linenos">564</span>
<span class="linenos">565</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">Consume</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
<span class="linenos">566</span>      <span class="p">(</span><span class="o">*</span><span class="n">batches_seen</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">567</span>      <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
<span class="linenos">568</span>    <span class="p">}</span>
<span class="linenos">569</span>
<span class="linenos">570</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">Finish</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">finish</span><span class="p">;</span> <span class="p">}</span>
<span class="linenos">571</span>
<span class="linenos">572</span>    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;*</span> <span class="n">batches_seen</span><span class="p">;</span>
<span class="linenos">573</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span><span class="p">;</span>
<span class="linenos">574</span>  <span class="p">};</span>
<span class="linenos">575</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CustomSinkNodeConsumer</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span>
<span class="linenos">576</span>      <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">CustomSinkNodeConsumer</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batches_seen</span><span class="p">,</span> <span class="n">finish</span><span class="p">);</span>
<span class="linenos">577</span>
<span class="linenos">578</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">consuming_sink</span><span class="p">;</span>
<span class="linenos">579</span>
<span class="linenos">580</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">consuming_sink</span><span class="p">,</span>
<span class="linenos">581</span>                        <span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;consuming_sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span>
<span class="linenos">582</span>                                     <span class="n">cp</span><span class="o">::</span><span class="n">ConsumingSinkNodeOptions</span><span class="p">(</span><span class="n">consumer</span><span class="p">)));</span>
<span class="linenos">583</span>
<span class="linenos">584</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">consuming_sink</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">585</span>
<span class="linenos">586</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">587</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exec Plan created: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">588</span>  <span class="c1">// plan start producing</span>
<span class="linenos">589</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">StartProducing</span><span class="p">());</span>
<span class="linenos">590</span>  <span class="c1">// Source should finish fairly quickly</span>
<span class="linenos">591</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">().</span><span class="n">status</span><span class="p">());</span>
<span class="linenos">592</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Source Finished!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">593</span>  <span class="c1">// Mark consumption complete, plan should finish</span>
<span class="linenos">594</span>  <span class="n">finish</span><span class="p">.</span><span class="n">MarkFinished</span><span class="p">(</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">());</span>
<span class="linenos">595</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">().</span><span class="n">status</span><span class="p">());</span>
<span class="linenos">596</span>  <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
<span class="linenos">597</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="order-by-sink">
<span id="stream-execution-order-by-sink-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">order_by_sink</span></code><a class="headerlink" href="#order-by-sink" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">order_by_sink</span></code> operation is an extension to the <code class="docutils literal notranslate"><span class="pre">sink</span></code> operation.
This operation provides the ability to guarantee the ordering of the
stream by providing the <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::OrderBySinkNodeOptions</span></code>.
Here the <a class="reference internal" href="api/compute.html#_CPPv4N5arrow7compute11SortOptionsE" title="arrow::compute::SortOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::compute::SortOptions</span></code></a> are provided to define which columns
are used for sorting and whether to sort by ascending or descending values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This node is a “pipeline breaker” and will fully materialize the dataset in memory.
In the future, spillover mechanisms will be added which should alleviate this
constraint.</p>
</div>
<p>Order-By-Sink example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">601</span><span class="cm">/**</span>
<span class="linenos">602</span><span class="cm"> * \brief</span>
<span class="linenos">603</span><span class="cm"> * Source-OrderBySink</span>
<span class="linenos">604</span><span class="cm"> * In this example, the data enters through the source node</span>
<span class="linenos">605</span><span class="cm"> * and the data is ordered in the sink node. The order can be</span>
<span class="linenos">606</span><span class="cm"> * ASCENDING or DESCENDING and it is configurable. The output</span>
<span class="linenos">607</span><span class="cm"> * is obtained as a table from the sink node.</span>
<span class="linenos">608</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">609</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">610</span><span class="cm"> */</span>
<span class="linenos">611</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceOrderBySinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">612</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">613</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">614</span>
<span class="linenos">615</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeSortTestBasicBatches</span><span class="p">());</span>
<span class="linenos">616</span>
<span class="linenos">617</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;basic data created&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">618</span>
<span class="linenos">619</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">620</span>
<span class="linenos">621</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">622</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">623</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">624</span>
<span class="linenos">625</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span>
<span class="linenos">626</span>      <span class="s">&quot;order_by_sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span>
<span class="linenos">627</span>      <span class="n">cp</span><span class="o">::</span><span class="n">OrderBySinkNodeOptions</span><span class="p">{</span>
<span class="linenos">628</span>          <span class="n">cp</span><span class="o">::</span><span class="n">SortOptions</span><span class="p">{{</span><span class="n">cp</span><span class="o">::</span><span class="n">SortKey</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">SortOrder</span><span class="o">::</span><span class="n">Descending</span><span class="p">}}},</span> <span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">629</span>
<span class="linenos">630</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">631</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="select-k-sink">
<span id="stream-execution-select-k-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">select_k_sink</span></code><a class="headerlink" href="#select-k-sink" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">select_k_sink</span></code> option enables selecting the top/bottom K elements,
similar to a SQL <code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span> <span class="pre">...</span> <span class="pre">LIMIT</span> <span class="pre">K</span></code> clause.
<a class="reference internal" href="api/compute.html#_CPPv4N5arrow7compute14SelectKOptionsE" title="arrow::compute::SelectKOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::compute::SelectKOptions</span></code></a> which is a defined by
using <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">OrderBySinkNode</span></code> definition. This option returns a sink node that receives
inputs and then compute top_k/bottom_k.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This node is a “pipeline breaker” and will fully materialize the input in memory.
In the future, spillover mechanisms will be added which should alleviate this
constraint.</p>
</div>
<p>SelectK example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">683</span><span class="cm">/**</span>
<span class="linenos">684</span><span class="cm"> * \brief</span>
<span class="linenos">685</span><span class="cm"> * Source-KSelect</span>
<span class="linenos">686</span><span class="cm"> * This example shows how K number of elements can be selected</span>
<span class="linenos">687</span><span class="cm"> * either from the top or bottom. The output node is a modified</span>
<span class="linenos">688</span><span class="cm"> * sink node where output can be obtained as a table.</span>
<span class="linenos">689</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">690</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">691</span><span class="cm"> */</span>
<span class="linenos">692</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceKSelectExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">693</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">input</span><span class="p">,</span> <span class="n">MakeGroupableBatches</span><span class="p">());</span>
<span class="linenos">694</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">695</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">696</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">697</span>
<span class="linenos">698</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">699</span>      <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">700</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span>
<span class="linenos">701</span>                       <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">input</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">gen</span><span class="p">()}));</span>
<span class="linenos">702</span>
<span class="linenos">703</span>  <span class="n">cp</span><span class="o">::</span><span class="n">SelectKOptions</span> <span class="n">options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SelectKOptions</span><span class="o">::</span><span class="n">TopKDefault</span><span class="p">(</span><span class="cm">/*k=*/</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s">&quot;i32&quot;</span><span class="p">});</span>
<span class="linenos">704</span>
<span class="linenos">705</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;select_k_sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span>
<span class="linenos">706</span>                                       <span class="n">cp</span><span class="o">::</span><span class="n">SelectKSinkNodeOptions</span><span class="p">{</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">707</span>
<span class="linenos">708</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">(</span>
<span class="linenos">709</span>      <span class="p">{</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;i32&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">())});</span>
<span class="linenos">710</span>
<span class="linenos">711</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">712</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="scan">
<span id="stream-execution-scan-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">scan</span></code><a class="headerlink" href="#scan" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">scan</span></code> is an operation used to load and process datasets.  It should be preferred over the
more generic <code class="docutils literal notranslate"><span class="pre">source</span></code> node when your input is a dataset.  The behavior is defined using
<a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset15ScanNodeOptionsE" title="arrow::dataset::ScanNodeOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::ScanNodeOptions</span></code></a>.  More information on datasets and the various
scan options can be found in <a class="reference internal" href="dataset.html"><span class="doc">Tabular Datasets</span></a>.</p>
<p>This node is capable of applying pushdown filters to the file readers which reduce
the amount of data that needs to be read.  This means you may supply the same
filter expression to the scan node that you also supply to the FilterNode because
the filtering is done in two different places.</p>
<p>Scan example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">289</span><span class="cm">/**</span>
<span class="linenos">290</span><span class="cm"> * \brief</span>
<span class="linenos">291</span><span class="cm"> * Scan-Sink</span>
<span class="linenos">292</span><span class="cm"> * This example shows how scan operation can be applied on a dataset.</span>
<span class="linenos">293</span><span class="cm"> * There are operations that can be applied on the scan (project, filter)</span>
<span class="linenos">294</span><span class="cm"> * and the input data can be processed. THe output is obtained as a table</span>
<span class="linenos">295</span><span class="cm"> * via the sink node.</span>
<span class="linenos">296</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">297</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">298</span><span class="cm"> */</span>
<span class="linenos">299</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">300</span>  <span class="c1">// Execution plan created</span>
<span class="linenos">301</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">302</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">303</span>
<span class="linenos">304</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">305</span>
<span class="linenos">306</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">307</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>  <span class="c1">// create empty projection</span>
<span class="linenos">308</span>
<span class="linenos">309</span>  <span class="c1">// construct the scan node</span>
<span class="linenos">310</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">311</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">312</span>
<span class="linenos">313</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">314</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">315</span>
<span class="linenos">316</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">317</span>
<span class="linenos">318</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">319</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">320</span>
<span class="linenos">321</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">dataset</span><span class="o">-&gt;</span><span class="n">schema</span><span class="p">(),</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">322</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="write">
<h3><code class="docutils literal notranslate"><span class="pre">write</span></code><a class="headerlink" href="#write" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">write</span></code> node saves query results as a dataset of files in a
format like Parquet, Feather, CSV, etc. using the <a class="reference internal" href="dataset.html"><span class="doc">Tabular Datasets</span></a>
functionality in Arrow. The write options are provided via the
<a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset16WriteNodeOptionsE" title="arrow::dataset::WriteNodeOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::WriteNodeOptions</span></code></a> which in turn contains
<a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset29FileSystemDatasetWriteOptionsE" title="arrow::dataset::FileSystemDatasetWriteOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::FileSystemDatasetWriteOptions</span></code></a>.
<a class="reference internal" href="api/dataset.html#_CPPv4N5arrow7dataset29FileSystemDatasetWriteOptionsE" title="arrow::dataset::FileSystemDatasetWriteOptions"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">arrow::dataset::FileSystemDatasetWriteOptions</span></code></a> provides
control over the written dataset, including options like the output
directory, file naming scheme, and so on.</p>
<p>Write example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">717</span><span class="cm">/**</span>
<span class="linenos">718</span><span class="cm"> * \brief</span>
<span class="linenos">719</span><span class="cm"> * Scan-Filter-Write</span>
<span class="linenos">720</span><span class="cm"> * This example shows how scan node can be used to load the data</span>
<span class="linenos">721</span><span class="cm"> * and after processing how it can be written to disk.</span>
<span class="linenos">722</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">723</span><span class="cm"> * \param file_path : file saving path</span>
<span class="linenos">724</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">725</span><span class="cm"> */</span>
<span class="linenos">726</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanFilterWriteExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">,</span>
<span class="linenos">727</span>                                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">file_path</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">728</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">729</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">730</span>
<span class="linenos">731</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">732</span>
<span class="linenos">733</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">734</span>  <span class="c1">// empty projection</span>
<span class="linenos">735</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>
<span class="linenos">736</span>
<span class="linenos">737</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">738</span>
<span class="linenos">739</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">740</span>
<span class="linenos">741</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">742</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">743</span>
<span class="linenos">744</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">745</span>
<span class="linenos">746</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">root_path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="linenos">747</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;file://&quot;</span> <span class="o">+</span> <span class="n">file_path</span><span class="p">;</span>
<span class="linenos">748</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">FileSystem</span><span class="o">&gt;</span> <span class="n">filesystem</span> <span class="o">=</span>
<span class="linenos">749</span>      <span class="n">arrow</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">FileSystemFromUri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_path</span><span class="p">).</span><span class="n">ValueOrDie</span><span class="p">();</span>
<span class="linenos">750</span>
<span class="linenos">751</span>  <span class="k">auto</span> <span class="n">base_path</span> <span class="o">=</span> <span class="n">root_path</span> <span class="o">+</span> <span class="s">&quot;/parquet_dataset&quot;</span><span class="p">;</span>
<span class="linenos">752</span>  <span class="c1">// Uncomment the following line, if run repeatedly</span>
<span class="linenos">753</span>  <span class="c1">// ARROW_RETURN_NOT_OK(filesystem-&gt;DeleteDirContents(base_path));</span>
<span class="linenos">754</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">filesystem</span><span class="o">-&gt;</span><span class="n">CreateDir</span><span class="p">(</span><span class="n">base_path</span><span class="p">));</span>
<span class="linenos">755</span>
<span class="linenos">756</span>  <span class="c1">// The partition schema determines which fields are part of the partitioning.</span>
<span class="linenos">757</span>  <span class="k">auto</span> <span class="n">partition_schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">())});</span>
<span class="linenos">758</span>  <span class="c1">// We&#39;ll use Hive-style partitioning,</span>
<span class="linenos">759</span>  <span class="c1">// which creates directories with &quot;key=value&quot; pairs.</span>
<span class="linenos">760</span>
<span class="linenos">761</span>  <span class="k">auto</span> <span class="n">partitioning</span> <span class="o">=</span>
<span class="linenos">762</span>      <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">HivePartitioning</span><span class="o">&gt;</span><span class="p">(</span><span class="n">partition_schema</span><span class="p">);</span>
<span class="linenos">763</span>  <span class="c1">// We&#39;ll write Parquet files.</span>
<span class="linenos">764</span>  <span class="k">auto</span> <span class="n">format</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ParquetFileFormat</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">765</span>
<span class="linenos">766</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">FileSystemDatasetWriteOptions</span> <span class="n">write_options</span><span class="p">;</span>
<span class="linenos">767</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">file_write_options</span> <span class="o">=</span> <span class="n">format</span><span class="o">-&gt;</span><span class="n">DefaultWriteOptions</span><span class="p">();</span>
<span class="linenos">768</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">filesystem</span> <span class="o">=</span> <span class="n">filesystem</span><span class="p">;</span>
<span class="linenos">769</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">base_dir</span> <span class="o">=</span> <span class="n">base_path</span><span class="p">;</span>
<span class="linenos">770</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">partitioning</span> <span class="o">=</span> <span class="n">partitioning</span><span class="p">;</span>
<span class="linenos">771</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">basename_template</span> <span class="o">=</span> <span class="s">&quot;part{i}.parquet&quot;</span><span class="p">;</span>
<span class="linenos">772</span>
<span class="linenos">773</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">WriteNodeOptions</span> <span class="n">write_node_options</span><span class="p">{</span><span class="n">write_options</span><span class="p">,</span> <span class="n">dataset</span><span class="o">-&gt;</span><span class="n">schema</span><span class="p">()};</span>
<span class="linenos">774</span>
<span class="linenos">775</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span> <span class="n">write_node_options</span><span class="p">));</span>
<span class="linenos">776</span>
<span class="linenos">777</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">778</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Execution Plan Created : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">779</span>  <span class="c1">// // // start the ExecPlan</span>
<span class="linenos">780</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">StartProducing</span><span class="p">());</span>
<span class="linenos">781</span>  <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">();</span>
<span class="linenos">782</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="n">status</span><span class="p">());</span>
<span class="linenos">783</span>  <span class="n">future</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
<span class="linenos">784</span>  <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
<span class="linenos">785</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="union">
<span id="stream-execution-union-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">union</span></code><a class="headerlink" href="#union" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">union</span></code> merges multiple data streams with the same schema into one, similar to
a SQL <code class="docutils literal notranslate"><span class="pre">UNION</span> <span class="pre">ALL</span></code> clause.</p>
<p>The following example demonstrates how this can be achieved using
two data sources.</p>
<p>Union example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">791</span><span class="cm">/**</span>
<span class="linenos">792</span><span class="cm"> * \brief</span>
<span class="linenos">793</span><span class="cm"> * Source-Union-Sink</span>
<span class="linenos">794</span><span class="cm"> * This example shows how a union operation can be applied on two</span>
<span class="linenos">795</span><span class="cm"> * data sources. The output is obtained as a table via the sink</span>
<span class="linenos">796</span><span class="cm"> * node.</span>
<span class="linenos">797</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">798</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">799</span><span class="cm"> */</span>
<span class="linenos">800</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceUnionSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">801</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">802</span>
<span class="linenos">803</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">).</span><span class="n">ValueOrDie</span><span class="p">();</span>
<span class="linenos">804</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">805</span>
<span class="linenos">806</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span> <span class="n">union_node</span><span class="p">{</span><span class="s">&quot;union&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">ExecNodeOptions</span><span class="p">{}};</span>
<span class="linenos">807</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span> <span class="n">lhs</span><span class="p">{</span><span class="s">&quot;source&quot;</span><span class="p">,</span>
<span class="linenos">808</span>                      <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()}};</span>
<span class="linenos">809</span>  <span class="n">lhs</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&quot;lhs&quot;</span><span class="p">;</span>
<span class="linenos">810</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span> <span class="n">rhs</span><span class="p">{</span><span class="s">&quot;source&quot;</span><span class="p">,</span>
<span class="linenos">811</span>                      <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()}};</span>
<span class="linenos">812</span>  <span class="n">rhs</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&quot;rhs&quot;</span><span class="p">;</span>
<span class="linenos">813</span>  <span class="n">union_node</span><span class="p">.</span><span class="n">inputs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
<span class="linenos">814</span>  <span class="n">union_node</span><span class="p">.</span><span class="n">inputs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
<span class="linenos">815</span>
<span class="linenos">816</span>  <span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span> <span class="n">options</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span><span class="o">::</span><span class="n">ONLY_VALID</span><span class="p">);</span>
<span class="linenos">817</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">818</span>      <span class="k">auto</span> <span class="n">declr</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span><span class="o">::</span><span class="n">Sequence</span><span class="p">({</span>
<span class="linenos">819</span>                                                <span class="n">union_node</span><span class="p">,</span>
<span class="linenos">820</span>                                                <span class="p">{</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}},</span>
<span class="linenos">821</span>                                            <span class="p">})</span>
<span class="linenos">822</span>                      <span class="p">.</span><span class="n">AddToPlan</span><span class="p">(</span><span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
<span class="linenos">823</span>
<span class="linenos">824</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">declr</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">825</span>
<span class="linenos">826</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">827</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">828</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="hash-join">
<span id="stream-execution-hashjoin-docs"></span><h3><code class="docutils literal notranslate"><span class="pre">hash_join</span></code><a class="headerlink" href="#hash-join" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">hash_join</span></code> operation provides the relational algebra operation, join using hash-based
algorithm. <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">:compute::HashJoinNodeOptions</span></code> contains the options required in
defining a join. The hash_join supports
<a class="reference external" href="https://en.wikipedia.org/wiki/Join_(SQL)">left/right/full semi/anti/outerjoins</a>.
Also the join-key (i.e. the column(s) to join on), and suffixes (i.e a suffix term like “_x”
which can be appended as a suffix for column names duplicated in both left and right
relations.) can be set via the the join options.
<a class="reference external" href="https://en.wikipedia.org/wiki/Hash_join">Read more on hash-joins</a>.</p>
<p>Hash-Join example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">637</span><span class="cm">/**</span>
<span class="linenos">638</span><span class="cm"> * \brief</span>
<span class="linenos">639</span><span class="cm"> * Source-HashJoin-Sink</span>
<span class="linenos">640</span><span class="cm"> * This example shows how source node gets the data and how a self-join</span>
<span class="linenos">641</span><span class="cm"> * is applied on the data. The join options are configurable. The output</span>
<span class="linenos">642</span><span class="cm"> * is obtained as a table via the sink node.</span>
<span class="linenos">643</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">644</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">645</span><span class="cm"> */</span>
<span class="linenos">646</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceHashJoinSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">647</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">input</span><span class="p">,</span> <span class="n">MakeGroupableBatches</span><span class="p">());</span>
<span class="linenos">648</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">649</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">650</span>
<span class="linenos">651</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">652</span>
<span class="linenos">653</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">left_source</span><span class="p">;</span>
<span class="linenos">654</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">right_source</span><span class="p">;</span>
<span class="linenos">655</span>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">source</span> <span class="p">:</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">left_source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right_source</span><span class="p">})</span> <span class="p">{</span>
<span class="linenos">656</span>    <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="o">*</span><span class="n">source</span><span class="p">,</span>
<span class="linenos">657</span>                          <span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span>
<span class="linenos">658</span>                                       <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">input</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">gen</span><span class="p">()}));</span>
<span class="linenos">659</span>  <span class="p">}</span>
<span class="linenos">660</span>
<span class="linenos">661</span>  <span class="n">cp</span><span class="o">::</span><span class="n">HashJoinNodeOptions</span> <span class="n">join_opts</span><span class="p">{</span>
<span class="linenos">662</span>      <span class="n">cp</span><span class="o">::</span><span class="n">JoinType</span><span class="o">::</span><span class="n">INNER</span><span class="p">,</span>
<span class="linenos">663</span>      <span class="cm">/*left_keys=*/</span><span class="p">{</span><span class="s">&quot;str&quot;</span><span class="p">},</span>
<span class="linenos">664</span>      <span class="cm">/*right_keys=*/</span><span class="p">{</span><span class="s">&quot;str&quot;</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">literal</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span> <span class="s">&quot;l_&quot;</span><span class="p">,</span> <span class="s">&quot;r_&quot;</span><span class="p">};</span>
<span class="linenos">665</span>
<span class="linenos">666</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">667</span>      <span class="k">auto</span> <span class="n">hashjoin</span><span class="p">,</span>
<span class="linenos">668</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;hashjoin&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">left_source</span><span class="p">,</span> <span class="n">right_source</span><span class="p">},</span> <span class="n">join_opts</span><span class="p">));</span>
<span class="linenos">669</span>
<span class="linenos">670</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">671</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">hashjoin</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">672</span>  <span class="c1">// expected columns i32, str, l_str, r_str</span>
<span class="linenos">673</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">(</span>
<span class="linenos">674</span>      <span class="p">{</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;i32&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">()),</span>
<span class="linenos">675</span>       <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;l_str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">()),</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;r_str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">())});</span>
<span class="linenos">676</span>
<span class="linenos">677</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">678</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="summary">
<span id="stream-execution-write-docs"></span><h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>There are examples of these nodes which can be found in
<code class="docutils literal notranslate"><span class="pre">cpp/examples/arrow/execution_plan_documentation_examples.cc</span></code> in the Arrow source.</p>
<p>Complete Example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 19</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/array.h&gt;</span><span class="cp"></span>
<span class="linenos"> 20</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/builder.h&gt;</span><span class="cp"></span>
<span class="linenos"> 21</span>
<span class="linenos"> 22</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/compute/api.h&gt;</span><span class="cp"></span>
<span class="linenos"> 23</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/compute/api_vector.h&gt;</span><span class="cp"></span>
<span class="linenos"> 24</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/compute/cast.h&gt;</span><span class="cp"></span>
<span class="linenos"> 25</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/compute/exec/exec_plan.h&gt;</span><span class="cp"></span>
<span class="linenos"> 26</span>
<span class="linenos"> 27</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/csv/api.h&gt;</span><span class="cp"></span>
<span class="linenos"> 28</span>
<span class="linenos"> 29</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/dataset/dataset.h&gt;</span><span class="cp"></span>
<span class="linenos"> 30</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/dataset/file_base.h&gt;</span><span class="cp"></span>
<span class="linenos"> 31</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/dataset/file_parquet.h&gt;</span><span class="cp"></span>
<span class="linenos"> 32</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/dataset/plan.h&gt;</span><span class="cp"></span>
<span class="linenos"> 33</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/dataset/scanner.h&gt;</span><span class="cp"></span>
<span class="linenos"> 34</span>
<span class="linenos"> 35</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/io/interfaces.h&gt;</span><span class="cp"></span>
<span class="linenos"> 36</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/io/memory.h&gt;</span><span class="cp"></span>
<span class="linenos"> 37</span>
<span class="linenos"> 38</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/result.h&gt;</span><span class="cp"></span>
<span class="linenos"> 39</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/status.h&gt;</span><span class="cp"></span>
<span class="linenos"> 40</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/table.h&gt;</span><span class="cp"></span>
<span class="linenos"> 41</span>
<span class="linenos"> 42</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/ipc/api.h&gt;</span><span class="cp"></span>
<span class="linenos"> 43</span>
<span class="linenos"> 44</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/util/future.h&gt;</span><span class="cp"></span>
<span class="linenos"> 45</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/util/range.h&gt;</span><span class="cp"></span>
<span class="linenos"> 46</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/util/thread_pool.h&gt;</span><span class="cp"></span>
<span class="linenos"> 47</span><span class="cp">#include</span> <span class="cpf">&lt;arrow/util/vector.h&gt;</span><span class="cp"></span>
<span class="linenos"> 48</span>
<span class="linenos"> 49</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="linenos"> 50</span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="linenos"> 51</span><span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="linenos"> 52</span>
<span class="linenos"> 53</span><span class="c1">// Demonstrate various operators in Arrow Streaming Execution Engine</span>
<span class="linenos"> 54</span>
<span class="linenos"> 55</span><span class="k">namespace</span> <span class="n">cp</span> <span class="o">=</span> <span class="o">::</span><span class="n">arrow</span><span class="o">::</span><span class="n">compute</span><span class="p">;</span>
<span class="linenos"> 56</span>
<span class="linenos"> 57</span><span class="k">constexpr</span> <span class="kt">char</span> <span class="n">kSep</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;******&quot;</span><span class="p">;</span>
<span class="linenos"> 58</span>
<span class="linenos"> 59</span><span class="kt">void</span> <span class="nf">PrintBlock</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 60</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">kSep</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">kSep</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos"> 61</span><span class="p">}</span>
<span class="linenos"> 62</span>
<span class="linenos"> 63</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TYPE</span><span class="p">,</span>
<span class="linenos"> 64</span>          <span class="k">typename</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">is_number_type</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">|</span>
<span class="linenos"> 65</span>                                             <span class="n">arrow</span><span class="o">::</span><span class="n">is_boolean_type</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">|</span>
<span class="linenos"> 66</span>                                             <span class="n">arrow</span><span class="o">::</span><span class="n">is_temporal_type</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
<span class="linenos"> 67</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Array</span><span class="o">&gt;&gt;</span> <span class="n">GetArrayDataSample</span><span class="p">(</span>
<span class="linenos"> 68</span>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">TYPE</span><span class="o">::</span><span class="n">c_type</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 69</span>  <span class="k">using</span> <span class="n">ARROW_ARRAY_TYPE</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">arrow</span><span class="o">::</span><span class="n">TypeTraits</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;::</span><span class="n">ArrayType</span><span class="p">;</span>
<span class="linenos"> 70</span>  <span class="k">using</span> <span class="n">ARROW_BUILDER_TYPE</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">arrow</span><span class="o">::</span><span class="n">TypeTraits</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;::</span><span class="n">BuilderType</span><span class="p">;</span>
<span class="linenos"> 71</span>  <span class="n">ARROW_BUILDER_TYPE</span> <span class="n">builder</span><span class="p">;</span>
<span class="linenos"> 72</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Reserve</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="linenos"> 73</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ARROW_ARRAY_TYPE</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">;</span>
<span class="linenos"> 74</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">AppendValues</span><span class="p">(</span><span class="n">values</span><span class="p">));</span>
<span class="linenos"> 75</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">));</span>
<span class="linenos"> 76</span>  <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="linenos"> 77</span><span class="p">}</span>
<span class="linenos"> 78</span>
<span class="linenos"> 79</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TYPE</span><span class="o">&gt;</span>
<span class="linenos"> 80</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Array</span><span class="o">&gt;&gt;</span> <span class="n">GetBinaryArrayDataSample</span><span class="p">(</span>
<span class="linenos"> 81</span>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">values</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 82</span>  <span class="k">using</span> <span class="n">ARROW_ARRAY_TYPE</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">arrow</span><span class="o">::</span><span class="n">TypeTraits</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;::</span><span class="n">ArrayType</span><span class="p">;</span>
<span class="linenos"> 83</span>  <span class="k">using</span> <span class="n">ARROW_BUILDER_TYPE</span> <span class="o">=</span> <span class="k">typename</span> <span class="nc">arrow</span><span class="o">::</span><span class="n">TypeTraits</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="o">&gt;::</span><span class="n">BuilderType</span><span class="p">;</span>
<span class="linenos"> 84</span>  <span class="n">ARROW_BUILDER_TYPE</span> <span class="n">builder</span><span class="p">;</span>
<span class="linenos"> 85</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Reserve</span><span class="p">(</span><span class="n">values</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="linenos"> 86</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ARROW_ARRAY_TYPE</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">;</span>
<span class="linenos"> 87</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">AppendValues</span><span class="p">(</span><span class="n">values</span><span class="p">));</span>
<span class="linenos"> 88</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">builder</span><span class="p">.</span><span class="n">Finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">));</span>
<span class="linenos"> 89</span>  <span class="k">return</span> <span class="n">array</span><span class="p">;</span>
<span class="linenos"> 90</span><span class="p">}</span>
<span class="linenos"> 91</span>
<span class="linenos"> 92</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">RecordBatch</span><span class="o">&gt;&gt;</span> <span class="n">GetSampleRecordBatch</span><span class="p">(</span>
<span class="linenos"> 93</span>    <span class="k">const</span> <span class="n">arrow</span><span class="o">::</span><span class="n">ArrayVector</span> <span class="n">array_vector</span><span class="p">,</span> <span class="k">const</span> <span class="n">arrow</span><span class="o">::</span><span class="n">FieldVector</span><span class="o">&amp;</span> <span class="n">field_vector</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos"> 94</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">RecordBatch</span><span class="o">&gt;</span> <span class="n">record_batch</span><span class="p">;</span>
<span class="linenos"> 95</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">struct_result</span><span class="p">,</span>
<span class="linenos"> 96</span>                        <span class="n">arrow</span><span class="o">::</span><span class="n">StructArray</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="n">array_vector</span><span class="p">,</span> <span class="n">field_vector</span><span class="p">));</span>
<span class="linenos"> 97</span>  <span class="k">return</span> <span class="n">record_batch</span><span class="o">-&gt;</span><span class="n">FromStructArray</span><span class="p">(</span><span class="n">struct_result</span><span class="p">);</span>
<span class="linenos"> 98</span><span class="p">}</span>
<span class="linenos"> 99</span>
<span class="linenos">100</span><span class="cm">/**</span>
<span class="linenos">101</span><span class="cm"> * \brief Get the Dataset object</span>
<span class="linenos">102</span><span class="cm"> *  Creating Dataset</span>
<span class="linenos">103</span><span class="cm"> *  a, b</span>
<span class="linenos">104</span><span class="cm">    1,null</span>
<span class="linenos">105</span><span class="cm">    2,true</span>
<span class="linenos">106</span><span class="cm">    null,true</span>
<span class="linenos">107</span><span class="cm">    3,false</span>
<span class="linenos">108</span><span class="cm">    null,true</span>
<span class="linenos">109</span><span class="cm">    4,false</span>
<span class="linenos">110</span><span class="cm">    5,null</span>
<span class="linenos">111</span><span class="cm">    6,false</span>
<span class="linenos">112</span><span class="cm">    7,false</span>
<span class="linenos">113</span><span class="cm">    8,true</span>
<span class="linenos">114</span><span class="cm"> * \return arrow::Result&lt;std::shared_ptr&lt;arrow::dataset::Dataset&gt;&gt;</span>
<span class="linenos">115</span><span class="cm"> */</span>
<span class="linenos">116</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;&gt;</span> <span class="n">GetDataset</span><span class="p">()</span> <span class="p">{</span>
<span class="linenos">117</span>  <span class="k">auto</span> <span class="n">null_long</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;::</span><span class="n">quiet_NaN</span><span class="p">();</span>
<span class="linenos">118</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">int64_array</span><span class="p">,</span>
<span class="linenos">119</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int64Type</span><span class="o">&gt;</span><span class="p">(</span>
<span class="linenos">120</span>                            <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">null_long</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">null_long</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}));</span>
<span class="linenos">121</span>
<span class="linenos">122</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">BooleanBuilder</span> <span class="n">boolean_builder</span><span class="p">;</span>
<span class="linenos">123</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">BooleanArray</span><span class="o">&gt;</span> <span class="n">bool_array</span><span class="p">;</span>
<span class="linenos">124</span>
<span class="linenos">125</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">bool_values</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>  <span class="nb">true</span><span class="p">,</span>  <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
<span class="linenos">126</span>                                      <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span>
<span class="linenos">127</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">is_valid</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>  <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>
<span class="linenos">128</span>                                <span class="nb">true</span><span class="p">,</span>  <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">true</span><span class="p">};</span>
<span class="linenos">129</span>
<span class="linenos">130</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">boolean_builder</span><span class="p">.</span><span class="n">Reserve</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
<span class="linenos">131</span>
<span class="linenos">132</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">boolean_builder</span><span class="p">.</span><span class="n">AppendValues</span><span class="p">(</span><span class="n">bool_values</span><span class="p">,</span> <span class="n">is_valid</span><span class="p">));</span>
<span class="linenos">133</span>
<span class="linenos">134</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">boolean_builder</span><span class="p">.</span><span class="n">Finish</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bool_array</span><span class="p">));</span>
<span class="linenos">135</span>
<span class="linenos">136</span>  <span class="k">auto</span> <span class="n">record_batch</span> <span class="o">=</span>
<span class="linenos">137</span>      <span class="n">arrow</span><span class="o">::</span><span class="n">RecordBatch</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int64</span><span class="p">()),</span>
<span class="linenos">138</span>                                              <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">boolean</span><span class="p">())}),</span>
<span class="linenos">139</span>                               <span class="mi">10</span><span class="p">,</span> <span class="p">{</span><span class="n">int64_array</span><span class="p">,</span> <span class="n">bool_array</span><span class="p">});</span>
<span class="linenos">140</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">table</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Table</span><span class="o">::</span><span class="n">FromRecordBatches</span><span class="p">({</span><span class="n">record_batch</span><span class="p">}));</span>
<span class="linenos">141</span>  <span class="k">auto</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">InMemoryDataset</span><span class="o">&gt;</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
<span class="linenos">142</span>  <span class="k">return</span> <span class="n">ds</span><span class="p">;</span>
<span class="linenos">143</span><span class="p">}</span>
<span class="linenos">144</span>
<span class="linenos">145</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;</span> <span class="n">GetExecBatchFromVectors</span><span class="p">(</span>
<span class="linenos">146</span>    <span class="k">const</span> <span class="n">arrow</span><span class="o">::</span><span class="n">FieldVector</span><span class="o">&amp;</span> <span class="n">field_vector</span><span class="p">,</span> <span class="k">const</span> <span class="n">arrow</span><span class="o">::</span><span class="n">ArrayVector</span><span class="o">&amp;</span> <span class="n">array_vector</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">147</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">RecordBatch</span><span class="o">&gt;</span> <span class="n">record_batch</span><span class="p">;</span>
<span class="linenos">148</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">res_batch</span><span class="p">,</span> <span class="n">GetSampleRecordBatch</span><span class="p">(</span><span class="n">array_vector</span><span class="p">,</span> <span class="n">field_vector</span><span class="p">));</span>
<span class="linenos">149</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">{</span><span class="o">*</span><span class="n">res_batch</span><span class="p">};</span>
<span class="linenos">150</span>  <span class="k">return</span> <span class="n">batch</span><span class="p">;</span>
<span class="linenos">151</span><span class="p">}</span>
<span class="linenos">152</span>
<span class="linenos">153</span><span class="c1">// (Doc section: BatchesWithSchema Definition)</span>
<span class="linenos">154</span><span class="k">struct</span> <span class="nc">BatchesWithSchema</span> <span class="p">{</span>
<span class="linenos">155</span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;</span> <span class="n">batches</span><span class="p">;</span>
<span class="linenos">156</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Schema</span><span class="o">&gt;</span> <span class="n">schema</span><span class="p">;</span>
<span class="linenos">157</span>  <span class="c1">// // This method uses internal arrow utilities to</span>
<span class="linenos">158</span>  <span class="c1">// // convert a vector of record batches to an AsyncGenerator of optional batches</span>
<span class="linenos">159</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">gen</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="linenos">160</span>    <span class="k">auto</span> <span class="n">opt_batches</span> <span class="o">=</span> <span class="o">::</span><span class="n">arrow</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">MapVector</span><span class="p">(</span>
<span class="linenos">161</span>        <span class="p">[](</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">make_optional</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">batch</span><span class="p">));</span> <span class="p">},</span>
<span class="linenos">162</span>        <span class="n">batches</span><span class="p">);</span>
<span class="linenos">163</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">gen</span><span class="p">;</span>
<span class="linenos">164</span>    <span class="n">gen</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">MakeVectorGenerator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">opt_batches</span><span class="p">));</span>
<span class="linenos">165</span>    <span class="k">return</span> <span class="n">gen</span><span class="p">;</span>
<span class="linenos">166</span>  <span class="p">}</span>
<span class="linenos">167</span><span class="p">};</span>
<span class="linenos">168</span><span class="c1">// (Doc section: BatchesWithSchema Definition)</span>
<span class="linenos">169</span>
<span class="linenos">170</span><span class="c1">// (Doc section: MakeBasicBatches Definition)</span>
<span class="linenos">171</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">BatchesWithSchema</span><span class="o">&gt;</span> <span class="n">MakeBasicBatches</span><span class="p">()</span> <span class="p">{</span>
<span class="linenos">172</span>  <span class="n">BatchesWithSchema</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">173</span>  <span class="k">auto</span> <span class="n">field_vector</span> <span class="o">=</span> <span class="p">{</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span>
<span class="linenos">174</span>                       <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">boolean</span><span class="p">())};</span>
<span class="linenos">175</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">}));</span>
<span class="linenos">176</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">}));</span>
<span class="linenos">177</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">}));</span>
<span class="linenos">178</span>
<span class="linenos">179</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1_bool</span><span class="p">,</span>
<span class="linenos">180</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">BooleanType</span><span class="o">&gt;</span><span class="p">({</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">}));</span>
<span class="linenos">181</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2_bool</span><span class="p">,</span>
<span class="linenos">182</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">BooleanType</span><span class="o">&gt;</span><span class="p">({</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">}));</span>
<span class="linenos">183</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3_bool</span><span class="p">,</span>
<span class="linenos">184</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">BooleanType</span><span class="o">&gt;</span><span class="p">({</span><span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">}));</span>
<span class="linenos">185</span>
<span class="linenos">186</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1</span><span class="p">,</span>
<span class="linenos">187</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">field_vector</span><span class="p">,</span> <span class="p">{</span><span class="n">b1_int</span><span class="p">,</span> <span class="n">b1_bool</span><span class="p">}));</span>
<span class="linenos">188</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2</span><span class="p">,</span>
<span class="linenos">189</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">field_vector</span><span class="p">,</span> <span class="p">{</span><span class="n">b2_int</span><span class="p">,</span> <span class="n">b2_bool</span><span class="p">}));</span>
<span class="linenos">190</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3</span><span class="p">,</span>
<span class="linenos">191</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">field_vector</span><span class="p">,</span> <span class="p">{</span><span class="n">b3_int</span><span class="p">,</span> <span class="n">b3_bool</span><span class="p">}));</span>
<span class="linenos">192</span>
<span class="linenos">193</span>  <span class="n">out</span><span class="p">.</span><span class="n">batches</span> <span class="o">=</span> <span class="p">{</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">};</span>
<span class="linenos">194</span>  <span class="n">out</span><span class="p">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">(</span><span class="n">field_vector</span><span class="p">);</span>
<span class="linenos">195</span>  <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">196</span><span class="p">}</span>
<span class="linenos">197</span><span class="c1">// (Doc section: MakeBasicBatches Definition)</span>
<span class="linenos">198</span>
<span class="linenos">199</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">BatchesWithSchema</span><span class="o">&gt;</span> <span class="n">MakeSortTestBasicBatches</span><span class="p">()</span> <span class="p">{</span>
<span class="linenos">200</span>  <span class="n">BatchesWithSchema</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">201</span>  <span class="k">auto</span> <span class="n">field</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">());</span>
<span class="linenos">202</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">}));</span>
<span class="linenos">203</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2_int</span><span class="p">,</span>
<span class="linenos">204</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">121</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">12</span><span class="p">}));</span>
<span class="linenos">205</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3_int</span><span class="p">,</span>
<span class="linenos">206</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">10</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">210</span><span class="p">,</span> <span class="mi">121</span><span class="p">}));</span>
<span class="linenos">207</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b4_int</span><span class="p">,</span>
<span class="linenos">208</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">51</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">34</span><span class="p">}));</span>
<span class="linenos">209</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b5_int</span><span class="p">,</span>
<span class="linenos">210</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">11</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">}));</span>
<span class="linenos">211</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b6_int</span><span class="p">,</span>
<span class="linenos">212</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">12</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">12</span><span class="p">}));</span>
<span class="linenos">213</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b7_int</span><span class="p">,</span>
<span class="linenos">214</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">210</span><span class="p">,</span> <span class="mi">11</span><span class="p">}));</span>
<span class="linenos">215</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b8_int</span><span class="p">,</span>
<span class="linenos">216</span>                        <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">51</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}));</span>
<span class="linenos">217</span>
<span class="linenos">218</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1</span><span class="p">,</span> <span class="n">GetExecBatchFromVectors</span><span class="p">({</span><span class="n">field</span><span class="p">},</span> <span class="p">{</span><span class="n">b1_int</span><span class="p">}));</span>
<span class="linenos">219</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2</span><span class="p">,</span> <span class="n">GetExecBatchFromVectors</span><span class="p">({</span><span class="n">field</span><span class="p">},</span> <span class="p">{</span><span class="n">b2_int</span><span class="p">}));</span>
<span class="linenos">220</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3</span><span class="p">,</span>
<span class="linenos">221</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">({</span><span class="n">field</span><span class="p">,</span> <span class="n">field</span><span class="p">},</span> <span class="p">{</span><span class="n">b3_int</span><span class="p">,</span> <span class="n">b8_int</span><span class="p">}));</span>
<span class="linenos">222</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b4</span><span class="p">,</span>
<span class="linenos">223</span>                        <span class="n">GetExecBatchFromVectors</span><span class="p">({</span><span class="n">field</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">field</span><span class="p">},</span>
<span class="linenos">224</span>                                                <span class="p">{</span><span class="n">b4_int</span><span class="p">,</span> <span class="n">b5_int</span><span class="p">,</span> <span class="n">b6_int</span><span class="p">,</span> <span class="n">b7_int</span><span class="p">}));</span>
<span class="linenos">225</span>  <span class="n">out</span><span class="p">.</span><span class="n">batches</span> <span class="o">=</span> <span class="p">{</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">b4</span><span class="p">};</span>
<span class="linenos">226</span>  <span class="n">out</span><span class="p">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">field</span><span class="p">});</span>
<span class="linenos">227</span>  <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">228</span><span class="p">}</span>
<span class="linenos">229</span>
<span class="linenos">230</span><span class="n">arrow</span><span class="o">::</span><span class="n">Result</span><span class="o">&lt;</span><span class="n">BatchesWithSchema</span><span class="o">&gt;</span> <span class="n">MakeGroupableBatches</span><span class="p">(</span><span class="kt">int</span> <span class="n">multiplicity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">231</span>  <span class="n">BatchesWithSchema</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">232</span>  <span class="k">auto</span> <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;i32&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">())};</span>
<span class="linenos">233</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">12</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">}));</span>
<span class="linenos">234</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">-2</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="mi">3</span><span class="p">}));</span>
<span class="linenos">235</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3_int</span><span class="p">,</span> <span class="n">GetArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Int32Type</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">-8</span><span class="p">}));</span>
<span class="linenos">236</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1_str</span><span class="p">,</span> <span class="n">GetBinaryArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">StringType</span><span class="o">&gt;</span><span class="p">(</span>
<span class="linenos">237</span>                                         <span class="p">{</span><span class="s">&quot;alpha&quot;</span><span class="p">,</span> <span class="s">&quot;beta&quot;</span><span class="p">,</span> <span class="s">&quot;alpha&quot;</span><span class="p">}));</span>
<span class="linenos">238</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2_str</span><span class="p">,</span> <span class="n">GetBinaryArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">StringType</span><span class="o">&gt;</span><span class="p">(</span>
<span class="linenos">239</span>                                         <span class="p">{</span><span class="s">&quot;alpha&quot;</span><span class="p">,</span> <span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="s">&quot;alpha&quot;</span><span class="p">}));</span>
<span class="linenos">240</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3_str</span><span class="p">,</span> <span class="n">GetBinaryArrayDataSample</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">StringType</span><span class="o">&gt;</span><span class="p">(</span>
<span class="linenos">241</span>                                         <span class="p">{</span><span class="s">&quot;gamma&quot;</span><span class="p">,</span> <span class="s">&quot;beta&quot;</span><span class="p">,</span> <span class="s">&quot;alpha&quot;</span><span class="p">}));</span>
<span class="linenos">242</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b1</span><span class="p">,</span> <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="p">{</span><span class="n">b1_int</span><span class="p">,</span> <span class="n">b1_str</span><span class="p">}));</span>
<span class="linenos">243</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b2</span><span class="p">,</span> <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="p">{</span><span class="n">b2_int</span><span class="p">,</span> <span class="n">b2_str</span><span class="p">}));</span>
<span class="linenos">244</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">b3</span><span class="p">,</span> <span class="n">GetExecBatchFromVectors</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="p">{</span><span class="n">b3_int</span><span class="p">,</span> <span class="n">b3_str</span><span class="p">}));</span>
<span class="linenos">245</span>  <span class="n">out</span><span class="p">.</span><span class="n">batches</span> <span class="o">=</span> <span class="p">{</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">};</span>
<span class="linenos">246</span>
<span class="linenos">247</span>  <span class="kt">size_t</span> <span class="n">batch_count</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="n">batches</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="linenos">248</span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">repeat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">repeat</span> <span class="o">&lt;</span> <span class="n">multiplicity</span><span class="p">;</span> <span class="o">++</span><span class="n">repeat</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">249</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batch_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">250</span>      <span class="n">out</span><span class="p">.</span><span class="n">batches</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">batches</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="linenos">251</span>    <span class="p">}</span>
<span class="linenos">252</span>  <span class="p">}</span>
<span class="linenos">253</span>
<span class="linenos">254</span>  <span class="n">out</span><span class="p">.</span><span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">(</span><span class="n">fields</span><span class="p">);</span>
<span class="linenos">255</span>  <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="linenos">256</span><span class="p">}</span>
<span class="linenos">257</span>
<span class="linenos">258</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ExecutePlanAndCollectAsTable</span><span class="p">(</span>
<span class="linenos">259</span>    <span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">260</span>    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Schema</span><span class="o">&gt;</span> <span class="n">schema</span><span class="p">,</span>
<span class="linenos">261</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">262</span>  <span class="c1">// // translate sink_gen (async) to sink_reader (sync)</span>
<span class="linenos">263</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">RecordBatchReader</span><span class="o">&gt;</span> <span class="n">sink_reader</span> <span class="o">=</span>
<span class="linenos">264</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeGeneratorReader</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">sink_gen</span><span class="p">),</span> <span class="n">exec_context</span><span class="p">.</span><span class="n">memory_pool</span><span class="p">());</span>
<span class="linenos">265</span>
<span class="linenos">266</span>  <span class="c1">// validate the ExecPlan</span>
<span class="linenos">267</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">268</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ExecPlan created : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">269</span>  <span class="c1">// // start the ExecPlan</span>
<span class="linenos">270</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">StartProducing</span><span class="p">());</span>
<span class="linenos">271</span>
<span class="linenos">272</span>  <span class="c1">// // collect sink_reader into a Table</span>
<span class="linenos">273</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">Table</span><span class="o">&gt;</span> <span class="n">response_table</span><span class="p">;</span>
<span class="linenos">274</span>
<span class="linenos">275</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">response_table</span><span class="p">,</span>
<span class="linenos">276</span>                        <span class="n">arrow</span><span class="o">::</span><span class="n">Table</span><span class="o">::</span><span class="n">FromRecordBatchReader</span><span class="p">(</span><span class="n">sink_reader</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
<span class="linenos">277</span>
<span class="linenos">278</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Results : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">response_table</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">279</span>
<span class="linenos">280</span>  <span class="c1">// // stop producing</span>
<span class="linenos">281</span>  <span class="n">plan</span><span class="o">-&gt;</span><span class="n">StopProducing</span><span class="p">();</span>
<span class="linenos">282</span>  <span class="c1">// // plan mark finished</span>
<span class="linenos">283</span>  <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">();</span>
<span class="linenos">284</span>  <span class="k">return</span> <span class="n">future</span><span class="p">.</span><span class="n">status</span><span class="p">();</span>
<span class="linenos">285</span><span class="p">}</span>
<span class="linenos">286</span>
<span class="linenos">287</span><span class="c1">// (Doc section: Scan Example)</span>
<span class="linenos">288</span><span class="cm">/**</span>
<span class="linenos">289</span><span class="cm"> * \brief</span>
<span class="linenos">290</span><span class="cm"> * Scan-Sink</span>
<span class="linenos">291</span><span class="cm"> * This example shows how scan operation can be applied on a dataset.</span>
<span class="linenos">292</span><span class="cm"> * There are operations that can be applied on the scan (project, filter)</span>
<span class="linenos">293</span><span class="cm"> * and the input data can be processed. THe output is obtained as a table</span>
<span class="linenos">294</span><span class="cm"> * via the sink node.</span>
<span class="linenos">295</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">296</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">297</span><span class="cm"> */</span>
<span class="linenos">298</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">299</span>  <span class="c1">// Execution plan created</span>
<span class="linenos">300</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">301</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">302</span>
<span class="linenos">303</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">304</span>
<span class="linenos">305</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">306</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>  <span class="c1">// create empty projection</span>
<span class="linenos">307</span>
<span class="linenos">308</span>  <span class="c1">// construct the scan node</span>
<span class="linenos">309</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">310</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">311</span>
<span class="linenos">312</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">313</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">314</span>
<span class="linenos">315</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">316</span>
<span class="linenos">317</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">318</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">319</span>
<span class="linenos">320</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">dataset</span><span class="o">-&gt;</span><span class="n">schema</span><span class="p">(),</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">321</span><span class="p">}</span>
<span class="linenos">322</span><span class="c1">// (Doc section: Scan Example)</span>
<span class="linenos">323</span>
<span class="linenos">324</span><span class="c1">// (Doc section: Source Example)</span>
<span class="linenos">325</span><span class="cm">/**</span>
<span class="linenos">326</span><span class="cm"> * \brief</span>
<span class="linenos">327</span><span class="cm"> * Source-Sink Example</span>
<span class="linenos">328</span><span class="cm"> * This example shows how a source and sink can be used</span>
<span class="linenos">329</span><span class="cm"> * in an execution plan. This includes source node receiving data</span>
<span class="linenos">330</span><span class="cm"> * and the sink node emits the data as an output represented in</span>
<span class="linenos">331</span><span class="cm"> * a table.</span>
<span class="linenos">332</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">333</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">334</span><span class="cm"> */</span>
<span class="linenos">335</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">336</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">337</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">338</span>
<span class="linenos">339</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">340</span>
<span class="linenos">341</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">342</span>
<span class="linenos">343</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">344</span>
<span class="linenos">345</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">346</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">347</span>
<span class="linenos">348</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">349</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">350</span>
<span class="linenos">351</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">352</span><span class="p">}</span>
<span class="linenos">353</span><span class="c1">// (Doc section: Source Example)</span>
<span class="linenos">354</span>
<span class="linenos">355</span><span class="c1">// (Doc section: Filter Example)</span>
<span class="linenos">356</span><span class="cm">/**</span>
<span class="linenos">357</span><span class="cm"> * \brief</span>
<span class="linenos">358</span><span class="cm"> * Source-Filter-Sink</span>
<span class="linenos">359</span><span class="cm"> * This example shows how a filter can be used in an execution plan,</span>
<span class="linenos">360</span><span class="cm"> * along with the source and sink operations. The output from the</span>
<span class="linenos">361</span><span class="cm"> * exeuction plan is obtained as a table via the sink node.</span>
<span class="linenos">362</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">363</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">364</span><span class="cm"> */</span>
<span class="linenos">365</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanFilterSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">366</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">367</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">368</span>
<span class="linenos">369</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">370</span>
<span class="linenos">371</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">372</span>  <span class="c1">// // specify the filter.  This filter removes all rows where the</span>
<span class="linenos">373</span>  <span class="c1">// value of the &quot;a&quot; column is greater than 3.</span>
<span class="linenos">374</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Expression</span> <span class="n">filter_opt</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">greater</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="n">cp</span><span class="o">::</span><span class="n">literal</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>
<span class="linenos">375</span>  <span class="c1">// set filter for scanner : on-disk / push-down filtering.</span>
<span class="linenos">376</span>  <span class="c1">// This step can be skipped if you are not reading from disk.</span>
<span class="linenos">377</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">filter</span> <span class="o">=</span> <span class="n">filter_opt</span><span class="p">;</span>
<span class="linenos">378</span>  <span class="c1">// empty projection</span>
<span class="linenos">379</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>
<span class="linenos">380</span>
<span class="linenos">381</span>  <span class="c1">// construct the scan node</span>
<span class="linenos">382</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Initialized Scanning Options&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">383</span>
<span class="linenos">384</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">385</span>
<span class="linenos">386</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">387</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Scan node options created&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">388</span>
<span class="linenos">389</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">390</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">391</span>
<span class="linenos">392</span>  <span class="c1">// pipe the scan node into a filter node</span>
<span class="linenos">393</span>  <span class="c1">// // Need to set the filter in scan node options and filter node options.</span>
<span class="linenos">394</span>  <span class="c1">// // At scan node it is used for on-disk / push-down filtering.</span>
<span class="linenos">395</span>  <span class="c1">// // At filter node it is used for in-memory filtering.</span>
<span class="linenos">396</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">filter</span><span class="p">;</span>
<span class="linenos">397</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">filter</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;filter&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span>
<span class="linenos">398</span>                                                 <span class="n">cp</span><span class="o">::</span><span class="n">FilterNodeOptions</span><span class="p">{</span><span class="n">filter_opt</span><span class="p">}));</span>
<span class="linenos">399</span>
<span class="linenos">400</span>  <span class="c1">// // finally, pipe the filter node into a sink node</span>
<span class="linenos">401</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">402</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">403</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">filter</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">404</span>
<span class="linenos">405</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">dataset</span><span class="o">-&gt;</span><span class="n">schema</span><span class="p">(),</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">406</span><span class="p">}</span>
<span class="linenos">407</span>
<span class="linenos">408</span><span class="c1">// (Doc section: Filter Example)</span>
<span class="linenos">409</span>
<span class="linenos">410</span><span class="c1">// (Doc section: Project Example)</span>
<span class="linenos">411</span><span class="cm">/**</span>
<span class="linenos">412</span><span class="cm"> * \brief</span>
<span class="linenos">413</span><span class="cm"> * Scan-Project-Sink</span>
<span class="linenos">414</span><span class="cm"> * This example shows how Scan operation can be used to load the data</span>
<span class="linenos">415</span><span class="cm"> * into the execution plan, how project operation can be applied on the</span>
<span class="linenos">416</span><span class="cm"> * data stream and how the output is obtained as a table via the sink node.</span>
<span class="linenos">417</span><span class="cm"> *</span>
<span class="linenos">418</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">419</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">420</span><span class="cm"> */</span>
<span class="linenos">421</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanProjectSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">422</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">423</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">424</span>
<span class="linenos">425</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">426</span>
<span class="linenos">427</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">428</span>  <span class="c1">// projection</span>
<span class="linenos">429</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Expression</span> <span class="n">a_times_2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">call</span><span class="p">(</span><span class="s">&quot;multiply&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">cp</span><span class="o">::</span><span class="n">field_ref</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">),</span> <span class="n">cp</span><span class="o">::</span><span class="n">literal</span><span class="p">(</span><span class="mi">2</span><span class="p">)});</span>
<span class="linenos">430</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>
<span class="linenos">431</span>
<span class="linenos">432</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">433</span>
<span class="linenos">434</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">435</span>
<span class="linenos">436</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">437</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">438</span>
<span class="linenos">439</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">project</span><span class="p">;</span>
<span class="linenos">440</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">project</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;project&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span>
<span class="linenos">441</span>                                                  <span class="n">cp</span><span class="o">::</span><span class="n">ProjectNodeOptions</span><span class="p">{{</span><span class="n">a_times_2</span><span class="p">}}));</span>
<span class="linenos">442</span>  <span class="c1">// schema after projection =&gt; multiply(a, 2): int64</span>
<span class="linenos">443</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Schema after projection : </span><span class="se">\n</span><span class="s">&quot;</span>
<span class="linenos">444</span>            <span class="o">&lt;&lt;</span> <span class="n">project</span><span class="o">-&gt;</span><span class="n">output_schema</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">445</span>
<span class="linenos">446</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">447</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">448</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">project</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">449</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a * 2&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">())});</span>
<span class="linenos">450</span>
<span class="linenos">451</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">452</span><span class="p">}</span>
<span class="linenos">453</span>
<span class="linenos">454</span><span class="c1">// (Doc section: Project Example)</span>
<span class="linenos">455</span>
<span class="linenos">456</span><span class="c1">// (Doc section: Scalar Aggregate Example)</span>
<span class="linenos">457</span><span class="cm">/**</span>
<span class="linenos">458</span><span class="cm"> * \brief</span>
<span class="linenos">459</span><span class="cm"> * Source-Aggregation-Sink</span>
<span class="linenos">460</span><span class="cm"> * This example shows how an aggregation operation can be applied on a</span>
<span class="linenos">461</span><span class="cm"> * execution plan resulting a scalar output. The source node loads the</span>
<span class="linenos">462</span><span class="cm"> * data and the aggregation (counting unique types in column &#39;a&#39;)</span>
<span class="linenos">463</span><span class="cm"> * is applied on this data. The output is obtained from the sink node as a table.</span>
<span class="linenos">464</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">465</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">466</span><span class="cm"> */</span>
<span class="linenos">467</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceScalarAggregateSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">468</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">469</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">470</span>
<span class="linenos">471</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">472</span>
<span class="linenos">473</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">474</span>
<span class="linenos">475</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">476</span>
<span class="linenos">477</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">478</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">479</span>  <span class="k">auto</span> <span class="n">aggregate_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">AggregateNodeOptions</span><span class="p">{</span><span class="cm">/*aggregates=*/</span><span class="p">{{</span><span class="s">&quot;sum&quot;</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">}},</span>
<span class="linenos">480</span>                                                    <span class="cm">/*targets=*/</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">},</span>
<span class="linenos">481</span>                                                    <span class="cm">/*names=*/</span><span class="p">{</span><span class="s">&quot;sum(a)&quot;</span><span class="p">}};</span>
<span class="linenos">482</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">483</span>      <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">aggregate</span><span class="p">,</span>
<span class="linenos">484</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;aggregate&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">aggregate_options</span><span class="p">));</span>
<span class="linenos">485</span>
<span class="linenos">486</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">487</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">aggregate</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">488</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;sum(a)&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">())});</span>
<span class="linenos">489</span>
<span class="linenos">490</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">491</span><span class="p">}</span>
<span class="linenos">492</span><span class="c1">// (Doc section: Scalar Aggregate Example)</span>
<span class="linenos">493</span>
<span class="linenos">494</span><span class="c1">// (Doc section: Group Aggregate Example)</span>
<span class="linenos">495</span><span class="cm">/**</span>
<span class="linenos">496</span><span class="cm"> * \brief</span>
<span class="linenos">497</span><span class="cm"> * Source-Aggregation-Sink</span>
<span class="linenos">498</span><span class="cm"> * This example shows how an aggregation operation can be applied on a</span>
<span class="linenos">499</span><span class="cm"> * execution plan resulting a grouped output. The source node loads the</span>
<span class="linenos">500</span><span class="cm"> * data and the aggregation (counting unique types in column &#39;a&#39;) is</span>
<span class="linenos">501</span><span class="cm"> * applied on this data. The output is obtained from the sink node as a table.</span>
<span class="linenos">502</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">503</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">504</span><span class="cm"> */</span>
<span class="linenos">505</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceGroupAggregateSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">506</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">507</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">508</span>
<span class="linenos">509</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">510</span>
<span class="linenos">511</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">512</span>
<span class="linenos">513</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">514</span>
<span class="linenos">515</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">516</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">517</span>  <span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span> <span class="n">options</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span><span class="o">::</span><span class="n">ONLY_VALID</span><span class="p">);</span>
<span class="linenos">518</span>  <span class="k">auto</span> <span class="n">aggregate_options</span> <span class="o">=</span>
<span class="linenos">519</span>      <span class="n">cp</span><span class="o">::</span><span class="n">AggregateNodeOptions</span><span class="p">{</span><span class="cm">/*aggregates=*/</span><span class="p">{{</span><span class="s">&quot;hash_count&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">}},</span>
<span class="linenos">520</span>                               <span class="cm">/*targets=*/</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">},</span>
<span class="linenos">521</span>                               <span class="cm">/*names=*/</span><span class="p">{</span><span class="s">&quot;count(a)&quot;</span><span class="p">},</span>
<span class="linenos">522</span>                               <span class="cm">/*keys=*/</span><span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">}};</span>
<span class="linenos">523</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">524</span>      <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">aggregate</span><span class="p">,</span>
<span class="linenos">525</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;aggregate&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span> <span class="n">aggregate_options</span><span class="p">));</span>
<span class="linenos">526</span>
<span class="linenos">527</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">528</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">aggregate</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">529</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span>
<span class="linenos">530</span>      <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;count(a)&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span>
<span class="linenos">531</span>      <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">boolean</span><span class="p">()),</span>
<span class="linenos">532</span>  <span class="p">});</span>
<span class="linenos">533</span>
<span class="linenos">534</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">535</span><span class="p">}</span>
<span class="linenos">536</span><span class="c1">// (Doc section: Group Aggregate Example)</span>
<span class="linenos">537</span>
<span class="linenos">538</span><span class="c1">// (Doc section: ConsumingSink Example)</span>
<span class="linenos">539</span><span class="cm">/**</span>
<span class="linenos">540</span><span class="cm"> * \brief</span>
<span class="linenos">541</span><span class="cm"> * Source-ConsumingSink</span>
<span class="linenos">542</span><span class="cm"> * This example shows how the data can be consumed within the execution plan</span>
<span class="linenos">543</span><span class="cm"> * by using a ConsumingSink node. There is no data output from this execution plan.</span>
<span class="linenos">544</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">545</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">546</span><span class="cm"> */</span>
<span class="linenos">547</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceConsumingSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">548</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">549</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">550</span>
<span class="linenos">551</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">552</span>
<span class="linenos">553</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">554</span>
<span class="linenos">555</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">556</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">557</span>
<span class="linenos">558</span>  <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">batches_seen</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="linenos">559</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;::</span><span class="n">Make</span><span class="p">();</span>
<span class="linenos">560</span>  <span class="k">struct</span> <span class="nc">CustomSinkNodeConsumer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeConsumer</span> <span class="p">{</span>
<span class="linenos">561</span>    <span class="n">CustomSinkNodeConsumer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;*</span> <span class="n">batches_seen</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span><span class="p">)</span>
<span class="linenos">562</span>        <span class="o">:</span> <span class="n">batches_seen</span><span class="p">(</span><span class="n">batches_seen</span><span class="p">),</span> <span class="n">finish</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">finish</span><span class="p">))</span> <span class="p">{}</span>
<span class="linenos">563</span>
<span class="linenos">564</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">Consume</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span> <span class="n">batch</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
<span class="linenos">565</span>      <span class="p">(</span><span class="o">*</span><span class="n">batches_seen</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">566</span>      <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
<span class="linenos">567</span>    <span class="p">}</span>
<span class="linenos">568</span>
<span class="linenos">569</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">Finish</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">finish</span><span class="p">;</span> <span class="p">}</span>
<span class="linenos">570</span>
<span class="linenos">571</span>    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;*</span> <span class="n">batches_seen</span><span class="p">;</span>
<span class="linenos">572</span>    <span class="n">arrow</span><span class="o">::</span><span class="n">Future</span><span class="o">&lt;&gt;</span> <span class="n">finish</span><span class="p">;</span>
<span class="linenos">573</span>  <span class="p">};</span>
<span class="linenos">574</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CustomSinkNodeConsumer</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span>
<span class="linenos">575</span>      <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">CustomSinkNodeConsumer</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batches_seen</span><span class="p">,</span> <span class="n">finish</span><span class="p">);</span>
<span class="linenos">576</span>
<span class="linenos">577</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">consuming_sink</span><span class="p">;</span>
<span class="linenos">578</span>
<span class="linenos">579</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">consuming_sink</span><span class="p">,</span>
<span class="linenos">580</span>                        <span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;consuming_sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span>
<span class="linenos">581</span>                                     <span class="n">cp</span><span class="o">::</span><span class="n">ConsumingSinkNodeOptions</span><span class="p">(</span><span class="n">consumer</span><span class="p">)));</span>
<span class="linenos">582</span>
<span class="linenos">583</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">consuming_sink</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">584</span>
<span class="linenos">585</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">586</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exec Plan created: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">587</span>  <span class="c1">// plan start producing</span>
<span class="linenos">588</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">StartProducing</span><span class="p">());</span>
<span class="linenos">589</span>  <span class="c1">// Source should finish fairly quickly</span>
<span class="linenos">590</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">source</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">().</span><span class="n">status</span><span class="p">());</span>
<span class="linenos">591</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Source Finished!&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">592</span>  <span class="c1">// Mark consumption complete, plan should finish</span>
<span class="linenos">593</span>  <span class="n">finish</span><span class="p">.</span><span class="n">MarkFinished</span><span class="p">(</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">());</span>
<span class="linenos">594</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">().</span><span class="n">status</span><span class="p">());</span>
<span class="linenos">595</span>  <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
<span class="linenos">596</span><span class="p">}</span>
<span class="linenos">597</span><span class="c1">// (Doc section: ConsumingSink Example)</span>
<span class="linenos">598</span>
<span class="linenos">599</span><span class="c1">// (Doc section: OrderBySink Example)</span>
<span class="linenos">600</span>
<span class="linenos">601</span><span class="cm">/**</span>
<span class="linenos">602</span><span class="cm"> * \brief</span>
<span class="linenos">603</span><span class="cm"> * Source-OrderBySink</span>
<span class="linenos">604</span><span class="cm"> * In this example, the data enters through the source node</span>
<span class="linenos">605</span><span class="cm"> * and the data is ordered in the sink node. The order can be</span>
<span class="linenos">606</span><span class="cm"> * ASCENDING or DESCENDING and it is configurable. The output</span>
<span class="linenos">607</span><span class="cm"> * is obtained as a table from the sink node.</span>
<span class="linenos">608</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">609</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">610</span><span class="cm"> */</span>
<span class="linenos">611</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceOrderBySinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">612</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">613</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">614</span>
<span class="linenos">615</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeSortTestBasicBatches</span><span class="p">());</span>
<span class="linenos">616</span>
<span class="linenos">617</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;basic data created&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">618</span>
<span class="linenos">619</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">620</span>
<span class="linenos">621</span>  <span class="k">auto</span> <span class="n">source_node_options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()};</span>
<span class="linenos">622</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">623</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">source_node_options</span><span class="p">));</span>
<span class="linenos">624</span>
<span class="linenos">625</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span>
<span class="linenos">626</span>      <span class="s">&quot;order_by_sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span>
<span class="linenos">627</span>      <span class="n">cp</span><span class="o">::</span><span class="n">OrderBySinkNodeOptions</span><span class="p">{</span>
<span class="linenos">628</span>          <span class="n">cp</span><span class="o">::</span><span class="n">SortOptions</span><span class="p">{{</span><span class="n">cp</span><span class="o">::</span><span class="n">SortKey</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">SortOrder</span><span class="o">::</span><span class="n">Descending</span><span class="p">}}},</span> <span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">629</span>
<span class="linenos">630</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">631</span><span class="p">}</span>
<span class="linenos">632</span>
<span class="linenos">633</span><span class="c1">// (Doc section: OrderBySink Example)</span>
<span class="linenos">634</span>
<span class="linenos">635</span><span class="c1">// (Doc section: HashJoin Example)</span>
<span class="linenos">636</span><span class="cm">/**</span>
<span class="linenos">637</span><span class="cm"> * \brief</span>
<span class="linenos">638</span><span class="cm"> * Source-HashJoin-Sink</span>
<span class="linenos">639</span><span class="cm"> * This example shows how source node gets the data and how a self-join</span>
<span class="linenos">640</span><span class="cm"> * is applied on the data. The join options are configurable. The output</span>
<span class="linenos">641</span><span class="cm"> * is obtained as a table via the sink node.</span>
<span class="linenos">642</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">643</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">644</span><span class="cm"> */</span>
<span class="linenos">645</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceHashJoinSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">646</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">input</span><span class="p">,</span> <span class="n">MakeGroupableBatches</span><span class="p">());</span>
<span class="linenos">647</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">648</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">649</span>
<span class="linenos">650</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">651</span>
<span class="linenos">652</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">left_source</span><span class="p">;</span>
<span class="linenos">653</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">right_source</span><span class="p">;</span>
<span class="linenos">654</span>  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">source</span> <span class="p">:</span> <span class="p">{</span><span class="o">&amp;</span><span class="n">left_source</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right_source</span><span class="p">})</span> <span class="p">{</span>
<span class="linenos">655</span>    <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="o">*</span><span class="n">source</span><span class="p">,</span>
<span class="linenos">656</span>                          <span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span>
<span class="linenos">657</span>                                       <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">input</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">gen</span><span class="p">()}));</span>
<span class="linenos">658</span>  <span class="p">}</span>
<span class="linenos">659</span>
<span class="linenos">660</span>  <span class="n">cp</span><span class="o">::</span><span class="n">HashJoinNodeOptions</span> <span class="n">join_opts</span><span class="p">{</span>
<span class="linenos">661</span>      <span class="n">cp</span><span class="o">::</span><span class="n">JoinType</span><span class="o">::</span><span class="n">INNER</span><span class="p">,</span>
<span class="linenos">662</span>      <span class="cm">/*left_keys=*/</span><span class="p">{</span><span class="s">&quot;str&quot;</span><span class="p">},</span>
<span class="linenos">663</span>      <span class="cm">/*right_keys=*/</span><span class="p">{</span><span class="s">&quot;str&quot;</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">literal</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span> <span class="s">&quot;l_&quot;</span><span class="p">,</span> <span class="s">&quot;r_&quot;</span><span class="p">};</span>
<span class="linenos">664</span>
<span class="linenos">665</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">666</span>      <span class="k">auto</span> <span class="n">hashjoin</span><span class="p">,</span>
<span class="linenos">667</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;hashjoin&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">left_source</span><span class="p">,</span> <span class="n">right_source</span><span class="p">},</span> <span class="n">join_opts</span><span class="p">));</span>
<span class="linenos">668</span>
<span class="linenos">669</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span>
<span class="linenos">670</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">hashjoin</span><span class="p">},</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">671</span>  <span class="c1">// expected columns i32, str, l_str, r_str</span>
<span class="linenos">672</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">(</span>
<span class="linenos">673</span>      <span class="p">{</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;i32&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">()),</span>
<span class="linenos">674</span>       <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;l_str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">()),</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;r_str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">())});</span>
<span class="linenos">675</span>
<span class="linenos">676</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">677</span><span class="p">}</span>
<span class="linenos">678</span>
<span class="linenos">679</span><span class="c1">// (Doc section: HashJoin Example)</span>
<span class="linenos">680</span>
<span class="linenos">681</span><span class="c1">// (Doc section: KSelect Example)</span>
<span class="linenos">682</span><span class="cm">/**</span>
<span class="linenos">683</span><span class="cm"> * \brief</span>
<span class="linenos">684</span><span class="cm"> * Source-KSelect</span>
<span class="linenos">685</span><span class="cm"> * This example shows how K number of elements can be selected</span>
<span class="linenos">686</span><span class="cm"> * either from the top or bottom. The output node is a modified</span>
<span class="linenos">687</span><span class="cm"> * sink node where output can be obtained as a table.</span>
<span class="linenos">688</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">689</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">690</span><span class="cm"> */</span>
<span class="linenos">691</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceKSelectExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">692</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">input</span><span class="p">,</span> <span class="n">MakeGroupableBatches</span><span class="p">());</span>
<span class="linenos">693</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">694</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">695</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">696</span>
<span class="linenos">697</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">698</span>      <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span> <span class="o">*</span> <span class="n">source</span><span class="p">,</span>
<span class="linenos">699</span>      <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;source&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span>
<span class="linenos">700</span>                       <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">input</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">gen</span><span class="p">()}));</span>
<span class="linenos">701</span>
<span class="linenos">702</span>  <span class="n">cp</span><span class="o">::</span><span class="n">SelectKOptions</span> <span class="n">options</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">SelectKOptions</span><span class="o">::</span><span class="n">TopKDefault</span><span class="p">(</span><span class="cm">/*k=*/</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="s">&quot;i32&quot;</span><span class="p">});</span>
<span class="linenos">703</span>
<span class="linenos">704</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;select_k_sink&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">source</span><span class="p">},</span>
<span class="linenos">705</span>                                       <span class="n">cp</span><span class="o">::</span><span class="n">SelectKSinkNodeOptions</span><span class="p">{</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}));</span>
<span class="linenos">706</span>
<span class="linenos">707</span>  <span class="k">auto</span> <span class="n">schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">(</span>
<span class="linenos">708</span>      <span class="p">{</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;i32&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">()),</span> <span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;str&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">utf8</span><span class="p">())});</span>
<span class="linenos">709</span>
<span class="linenos">710</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">711</span><span class="p">}</span>
<span class="linenos">712</span>
<span class="linenos">713</span><span class="c1">// (Doc section: KSelect Example)</span>
<span class="linenos">714</span>
<span class="linenos">715</span><span class="c1">// (Doc section: Write Example)</span>
<span class="linenos">716</span>
<span class="linenos">717</span><span class="cm">/**</span>
<span class="linenos">718</span><span class="cm"> * \brief</span>
<span class="linenos">719</span><span class="cm"> * Scan-Filter-Write</span>
<span class="linenos">720</span><span class="cm"> * This example shows how scan node can be used to load the data</span>
<span class="linenos">721</span><span class="cm"> * and after processing how it can be written to disk.</span>
<span class="linenos">722</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">723</span><span class="cm"> * \param file_path : file saving path</span>
<span class="linenos">724</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">725</span><span class="cm"> */</span>
<span class="linenos">726</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">ScanFilterWriteExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">,</span>
<span class="linenos">727</span>                                     <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">file_path</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">728</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span><span class="p">,</span>
<span class="linenos">729</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">));</span>
<span class="linenos">730</span>
<span class="linenos">731</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">Dataset</span><span class="o">&gt;</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">GetDataset</span><span class="p">());</span>
<span class="linenos">732</span>
<span class="linenos">733</span>  <span class="k">auto</span> <span class="n">options</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanOptions</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">734</span>  <span class="c1">// empty projection</span>
<span class="linenos">735</span>  <span class="n">options</span><span class="o">-&gt;</span><span class="n">projection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">project</span><span class="p">({},</span> <span class="p">{});</span>
<span class="linenos">736</span>
<span class="linenos">737</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecNode</span><span class="o">*</span> <span class="n">scan</span><span class="p">;</span>
<span class="linenos">738</span>
<span class="linenos">739</span>  <span class="k">auto</span> <span class="n">scan_node_options</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ScanNodeOptions</span><span class="p">{</span><span class="n">dataset</span><span class="p">,</span> <span class="n">options</span><span class="p">};</span>
<span class="linenos">740</span>
<span class="linenos">741</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="n">scan</span><span class="p">,</span>
<span class="linenos">742</span>                        <span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;scan&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{},</span> <span class="n">scan_node_options</span><span class="p">));</span>
<span class="linenos">743</span>
<span class="linenos">744</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">745</span>
<span class="linenos">746</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">root_path</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="linenos">747</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uri</span> <span class="o">=</span> <span class="s">&quot;file://&quot;</span> <span class="o">+</span> <span class="n">file_path</span><span class="p">;</span>
<span class="linenos">748</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">FileSystem</span><span class="o">&gt;</span> <span class="n">filesystem</span> <span class="o">=</span>
<span class="linenos">749</span>      <span class="n">arrow</span><span class="o">::</span><span class="n">fs</span><span class="o">::</span><span class="n">FileSystemFromUri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_path</span><span class="p">).</span><span class="n">ValueOrDie</span><span class="p">();</span>
<span class="linenos">750</span>
<span class="linenos">751</span>  <span class="k">auto</span> <span class="n">base_path</span> <span class="o">=</span> <span class="n">root_path</span> <span class="o">+</span> <span class="s">&quot;/parquet_dataset&quot;</span><span class="p">;</span>
<span class="linenos">752</span>  <span class="c1">// Uncomment the following line, if run repeatedly</span>
<span class="linenos">753</span>  <span class="c1">// ARROW_RETURN_NOT_OK(filesystem-&gt;DeleteDirContents(base_path));</span>
<span class="linenos">754</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">filesystem</span><span class="o">-&gt;</span><span class="n">CreateDir</span><span class="p">(</span><span class="n">base_path</span><span class="p">));</span>
<span class="linenos">755</span>
<span class="linenos">756</span>  <span class="c1">// The partition schema determines which fields are part of the partitioning.</span>
<span class="linenos">757</span>  <span class="k">auto</span> <span class="n">partition_schema</span> <span class="o">=</span> <span class="n">arrow</span><span class="o">::</span><span class="n">schema</span><span class="p">({</span><span class="n">arrow</span><span class="o">::</span><span class="n">field</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="n">arrow</span><span class="o">::</span><span class="n">int32</span><span class="p">())});</span>
<span class="linenos">758</span>  <span class="c1">// We&#39;ll use Hive-style partitioning,</span>
<span class="linenos">759</span>  <span class="c1">// which creates directories with &quot;key=value&quot; pairs.</span>
<span class="linenos">760</span>
<span class="linenos">761</span>  <span class="k">auto</span> <span class="n">partitioning</span> <span class="o">=</span>
<span class="linenos">762</span>      <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">HivePartitioning</span><span class="o">&gt;</span><span class="p">(</span><span class="n">partition_schema</span><span class="p">);</span>
<span class="linenos">763</span>  <span class="c1">// We&#39;ll write Parquet files.</span>
<span class="linenos">764</span>  <span class="k">auto</span> <span class="n">format</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">ParquetFileFormat</span><span class="o">&gt;</span><span class="p">();</span>
<span class="linenos">765</span>
<span class="linenos">766</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">FileSystemDatasetWriteOptions</span> <span class="n">write_options</span><span class="p">;</span>
<span class="linenos">767</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">file_write_options</span> <span class="o">=</span> <span class="n">format</span><span class="o">-&gt;</span><span class="n">DefaultWriteOptions</span><span class="p">();</span>
<span class="linenos">768</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">filesystem</span> <span class="o">=</span> <span class="n">filesystem</span><span class="p">;</span>
<span class="linenos">769</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">base_dir</span> <span class="o">=</span> <span class="n">base_path</span><span class="p">;</span>
<span class="linenos">770</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">partitioning</span> <span class="o">=</span> <span class="n">partitioning</span><span class="p">;</span>
<span class="linenos">771</span>  <span class="n">write_options</span><span class="p">.</span><span class="n">basename_template</span> <span class="o">=</span> <span class="s">&quot;part{i}.parquet&quot;</span><span class="p">;</span>
<span class="linenos">772</span>
<span class="linenos">773</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">WriteNodeOptions</span> <span class="n">write_node_options</span><span class="p">{</span><span class="n">write_options</span><span class="p">,</span> <span class="n">dataset</span><span class="o">-&gt;</span><span class="n">schema</span><span class="p">()};</span>
<span class="linenos">774</span>
<span class="linenos">775</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">MakeExecNode</span><span class="p">(</span><span class="s">&quot;write&quot;</span><span class="p">,</span> <span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="p">{</span><span class="n">scan</span><span class="p">},</span> <span class="n">write_node_options</span><span class="p">));</span>
<span class="linenos">776</span>
<span class="linenos">777</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">778</span>  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Execution Plan Created : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">779</span>  <span class="c1">// // // start the ExecPlan</span>
<span class="linenos">780</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">StartProducing</span><span class="p">());</span>
<span class="linenos">781</span>  <span class="k">auto</span> <span class="n">future</span> <span class="o">=</span> <span class="n">plan</span><span class="o">-&gt;</span><span class="n">finished</span><span class="p">();</span>
<span class="linenos">782</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="n">status</span><span class="p">());</span>
<span class="linenos">783</span>  <span class="n">future</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
<span class="linenos">784</span>  <span class="k">return</span> <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">();</span>
<span class="linenos">785</span><span class="p">}</span>
<span class="linenos">786</span>
<span class="linenos">787</span><span class="c1">// (Doc section: Write Example)</span>
<span class="linenos">788</span>
<span class="linenos">789</span><span class="c1">// (Doc section: Union Example)</span>
<span class="linenos">790</span>
<span class="linenos">791</span><span class="cm">/**</span>
<span class="linenos">792</span><span class="cm"> * \brief</span>
<span class="linenos">793</span><span class="cm"> * Source-Union-Sink</span>
<span class="linenos">794</span><span class="cm"> * This example shows how a union operation can be applied on two</span>
<span class="linenos">795</span><span class="cm"> * data sources. The output is obtained as a table via the sink</span>
<span class="linenos">796</span><span class="cm"> * node.</span>
<span class="linenos">797</span><span class="cm"> * \param exec_context : execution context</span>
<span class="linenos">798</span><span class="cm"> * \return arrow::Status</span>
<span class="linenos">799</span><span class="cm"> */</span>
<span class="linenos">800</span><span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">SourceUnionSinkExample</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span><span class="o">&amp;</span> <span class="n">exec_context</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">801</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span><span class="k">auto</span> <span class="n">basic_data</span><span class="p">,</span> <span class="n">MakeBasicBatches</span><span class="p">());</span>
<span class="linenos">802</span>
<span class="linenos">803</span>  <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">&gt;</span> <span class="n">plan</span> <span class="o">=</span> <span class="n">cp</span><span class="o">::</span><span class="n">ExecPlan</span><span class="o">::</span><span class="n">Make</span><span class="p">(</span><span class="o">&amp;</span><span class="n">exec_context</span><span class="p">).</span><span class="n">ValueOrDie</span><span class="p">();</span>
<span class="linenos">804</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">AsyncGenerator</span><span class="o">&lt;</span><span class="n">arrow</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">cp</span><span class="o">::</span><span class="n">ExecBatch</span><span class="o">&gt;&gt;</span> <span class="n">sink_gen</span><span class="p">;</span>
<span class="linenos">805</span>
<span class="linenos">806</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span> <span class="n">union_node</span><span class="p">{</span><span class="s">&quot;union&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">ExecNodeOptions</span><span class="p">{}};</span>
<span class="linenos">807</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span> <span class="n">lhs</span><span class="p">{</span><span class="s">&quot;source&quot;</span><span class="p">,</span>
<span class="linenos">808</span>                      <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()}};</span>
<span class="linenos">809</span>  <span class="n">lhs</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&quot;lhs&quot;</span><span class="p">;</span>
<span class="linenos">810</span>  <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span> <span class="n">rhs</span><span class="p">{</span><span class="s">&quot;source&quot;</span><span class="p">,</span>
<span class="linenos">811</span>                      <span class="n">cp</span><span class="o">::</span><span class="n">SourceNodeOptions</span><span class="p">{</span><span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">gen</span><span class="p">()}};</span>
<span class="linenos">812</span>  <span class="n">rhs</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&quot;rhs&quot;</span><span class="p">;</span>
<span class="linenos">813</span>  <span class="n">union_node</span><span class="p">.</span><span class="n">inputs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">lhs</span><span class="p">);</span>
<span class="linenos">814</span>  <span class="n">union_node</span><span class="p">.</span><span class="n">inputs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
<span class="linenos">815</span>
<span class="linenos">816</span>  <span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span> <span class="n">options</span><span class="p">(</span><span class="n">cp</span><span class="o">::</span><span class="n">CountOptions</span><span class="o">::</span><span class="n">ONLY_VALID</span><span class="p">);</span>
<span class="linenos">817</span>  <span class="n">ARROW_ASSIGN_OR_RAISE</span><span class="p">(</span>
<span class="linenos">818</span>      <span class="k">auto</span> <span class="n">declr</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">Declaration</span><span class="o">::</span><span class="n">Sequence</span><span class="p">({</span>
<span class="linenos">819</span>                                                <span class="n">union_node</span><span class="p">,</span>
<span class="linenos">820</span>                                                <span class="p">{</span><span class="s">&quot;sink&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="o">::</span><span class="n">SinkNodeOptions</span><span class="p">{</span><span class="o">&amp;</span><span class="n">sink_gen</span><span class="p">}},</span>
<span class="linenos">821</span>                                            <span class="p">})</span>
<span class="linenos">822</span>                      <span class="p">.</span><span class="n">AddToPlan</span><span class="p">(</span><span class="n">plan</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
<span class="linenos">823</span>
<span class="linenos">824</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">declr</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">825</span>
<span class="linenos">826</span>  <span class="n">ARROW_RETURN_NOT_OK</span><span class="p">(</span><span class="n">plan</span><span class="o">-&gt;</span><span class="n">Validate</span><span class="p">());</span>
<span class="linenos">827</span>  <span class="k">return</span> <span class="nf">ExecutePlanAndCollectAsTable</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">plan</span><span class="p">,</span> <span class="n">basic_data</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="n">sink_gen</span><span class="p">);</span>
<span class="linenos">828</span><span class="p">}</span>
<span class="linenos">829</span>
<span class="linenos">830</span><span class="c1">// (Doc section: Union Example)</span>
<span class="linenos">831</span>
<span class="linenos">832</span><span class="k">enum</span> <span class="nc">ExampleMode</span> <span class="p">{</span>
<span class="linenos">833</span>  <span class="n">SOURCE_SINK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="linenos">834</span>  <span class="n">SCAN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="linenos">835</span>  <span class="n">FILTER</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="linenos">836</span>  <span class="n">PROJECT</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="linenos">837</span>  <span class="n">SCALAR_AGGREGATION</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
<span class="linenos">838</span>  <span class="n">GROUP_AGGREGATION</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="linenos">839</span>  <span class="n">CONSUMING_SINK</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
<span class="linenos">840</span>  <span class="n">ORDER_BY_SINK</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<span class="linenos">841</span>  <span class="n">HASHJOIN</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
<span class="linenos">842</span>  <span class="n">KSELECT</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
<span class="linenos">843</span>  <span class="n">WRITE</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="linenos">844</span>  <span class="n">UNION</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
<span class="linenos">845</span><span class="p">};</span>
<span class="linenos">846</span>
<span class="linenos">847</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">848</span>  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">849</span>    <span class="c1">// Fake success for CI purposes.</span>
<span class="linenos">850</span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="linenos">851</span>  <span class="p">}</span>
<span class="linenos">852</span>
<span class="linenos">853</span>  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">base_save_path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="linenos">854</span>  <span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="linenos">855</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
<span class="linenos">856</span>  <span class="c1">// ensure arrow::dataset node factories are in the registry</span>
<span class="linenos">857</span>  <span class="n">arrow</span><span class="o">::</span><span class="n">dataset</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">Initialize</span><span class="p">();</span>
<span class="linenos">858</span>  <span class="c1">// execution context</span>
<span class="linenos">859</span>  <span class="n">cp</span><span class="o">::</span><span class="n">ExecContext</span> <span class="n">exec_context</span><span class="p">(</span><span class="n">arrow</span><span class="o">::</span><span class="n">default_memory_pool</span><span class="p">(),</span>
<span class="linenos">860</span>                               <span class="o">::</span><span class="n">arrow</span><span class="o">::</span><span class="n">internal</span><span class="o">::</span><span class="n">GetCpuThreadPool</span><span class="p">());</span>
<span class="linenos">861</span>  <span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
<span class="linenos">862</span>    <span class="k">case</span> <span class="nl">SOURCE_SINK</span><span class="p">:</span>
<span class="linenos">863</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Source Sink Example&quot;</span><span class="p">);</span>
<span class="linenos">864</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">865</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">866</span>    <span class="k">case</span> <span class="nl">SCAN</span><span class="p">:</span>
<span class="linenos">867</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Scan Example&quot;</span><span class="p">);</span>
<span class="linenos">868</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">ScanSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">869</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">870</span>    <span class="k">case</span> <span class="nl">FILTER</span><span class="p">:</span>
<span class="linenos">871</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Filter Example&quot;</span><span class="p">);</span>
<span class="linenos">872</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">ScanFilterSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">873</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">874</span>    <span class="k">case</span> <span class="nl">PROJECT</span><span class="p">:</span>
<span class="linenos">875</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Project Example&quot;</span><span class="p">);</span>
<span class="linenos">876</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">ScanProjectSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">877</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">878</span>    <span class="k">case</span> <span class="nl">GROUP_AGGREGATION</span><span class="p">:</span>
<span class="linenos">879</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Aggregate Example&quot;</span><span class="p">);</span>
<span class="linenos">880</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceGroupAggregateSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">881</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">882</span>    <span class="k">case</span> <span class="nl">SCALAR_AGGREGATION</span><span class="p">:</span>
<span class="linenos">883</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Aggregate Example&quot;</span><span class="p">);</span>
<span class="linenos">884</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceScalarAggregateSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">885</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">886</span>    <span class="k">case</span> <span class="nl">CONSUMING_SINK</span><span class="p">:</span>
<span class="linenos">887</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Consuming-Sink Example&quot;</span><span class="p">);</span>
<span class="linenos">888</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceConsumingSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">889</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">890</span>    <span class="k">case</span> <span class="nl">ORDER_BY_SINK</span><span class="p">:</span>
<span class="linenos">891</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;OrderBy Example&quot;</span><span class="p">);</span>
<span class="linenos">892</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceOrderBySinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">893</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">894</span>    <span class="k">case</span> <span class="nl">HASHJOIN</span><span class="p">:</span>
<span class="linenos">895</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;HashJoin Example&quot;</span><span class="p">);</span>
<span class="linenos">896</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceHashJoinSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">897</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">898</span>    <span class="k">case</span> <span class="nl">KSELECT</span><span class="p">:</span>
<span class="linenos">899</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;KSelect Example&quot;</span><span class="p">);</span>
<span class="linenos">900</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceKSelectExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">901</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">902</span>    <span class="k">case</span> <span class="nl">WRITE</span><span class="p">:</span>
<span class="linenos">903</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Write Example&quot;</span><span class="p">);</span>
<span class="linenos">904</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">ScanFilterWriteExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">,</span> <span class="n">base_save_path</span><span class="p">);</span>
<span class="linenos">905</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">906</span>    <span class="k">case</span> <span class="nl">UNION</span><span class="p">:</span>
<span class="linenos">907</span>      <span class="n">PrintBlock</span><span class="p">(</span><span class="s">&quot;Union Example&quot;</span><span class="p">);</span>
<span class="linenos">908</span>      <span class="n">status</span> <span class="o">=</span> <span class="n">SourceUnionSinkExample</span><span class="p">(</span><span class="n">exec_context</span><span class="p">);</span>
<span class="linenos">909</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">910</span>    <span class="k">default</span><span class="o">:</span>
<span class="linenos">911</span>      <span class="k">break</span><span class="p">;</span>
<span class="linenos">912</span>  <span class="p">}</span>
<span class="linenos">913</span>
<span class="linenos">914</span>  <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
<span class="linenos">915</span>    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="linenos">916</span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="linenos">917</span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error occurred: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">status</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="linenos">918</span>    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="linenos">919</span>  <span class="p">}</span>
<span class="linenos">920</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="compute.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Compute Functions</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="io.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Input / output and filesystems</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2016-2022 Apache Software Foundation.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.2.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>